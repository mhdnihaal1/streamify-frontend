import { hasAudio, hasScreenShareAudio, CallingState, hasVideo, hasScreenShare, OwnCapability, Browsers, VisibilityState, hasPausedTrack, createSoundDetector, SfuModels, isPinned, name, NoiseCancellationSettingsModeEnum, paginatedLayoutSortPreset, combineComparators, screenSharing, speakerLayoutSortPreset, CallTypes, defaultSortPreset, humanize, setSdkInfo } from '@stream-io/video-client';
export * from '@stream-io/video-client';
import { useCall, useCallStateHooks, useI18n, Restricted, useToggleCallRecording, useConnectedUser, StreamCallProvider, StreamVideoProvider, useStreamVideoClient, useEffectEvent } from '@stream-io/video-react-bindings';
export * from '@stream-io/video-react-bindings';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useState, useEffect, Fragment as Fragment$1, createContext, useContext, useRef, useCallback, useMemo, isValidElement, forwardRef, useLayoutEffect, lazy, Suspense } from 'react';
import { useFloating, offset, shift, flip, size, autoUpdate, FloatingOverlay, FloatingPortal, arrow, FloatingArrow, useListItem, useListNavigation, useTypeahead, useClick, useDismiss, useRole, useInteractions, FloatingFocusManager, FloatingList, useHover } from '@floating-ui/react';
import clsx from 'clsx';

const Audio = ({ participant, trackType = 'audioTrack', ...rest }) => {
    const call = useCall();
    const [audioElement, setAudioElement] = useState(null);
    const { userId, sessionId } = participant;
    useEffect(() => {
        if (!call || !audioElement)
            return;
        const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);
        return () => {
            cleanup?.();
        };
    }, [call, sessionId, audioElement, trackType]);
    return (jsx("audio", { autoPlay: true, ...rest, ref: setAudioElement, "data-user-id": userId, "data-session-id": sessionId, "data-track-type": trackType }));
};
Audio.displayName = 'Audio';

const ParticipantsAudio = (props) => {
    const { participants, audioProps } = props;
    return (jsx(Fragment, { children: participants.map((participant) => {
            if (participant.isLocalParticipant)
                return null;
            const { audioStream, screenShareAudioStream, sessionId } = participant;
            const hasAudioTrack = hasAudio(participant);
            const audioTrackElement = hasAudioTrack && audioStream && (jsx(Audio, { ...audioProps, trackType: "audioTrack", participant: participant }));
            const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
            const screenShareAudioTrackElement = hasScreenShareAudioTrack &&
                screenShareAudioStream && (jsx(Audio, { ...audioProps, trackType: "screenShareAudioTrack", participant: participant }));
            return (jsxs(Fragment$1, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId));
        }) }));
};
ParticipantsAudio.displayName = 'ParticipantsAudio';

const ParticipantViewContext = createContext(undefined);
const useParticipantViewContext = () => useContext(ParticipantViewContext);

const useFloatingUIPreset = ({ middleware = [], placement, strategy, offset: offsetInPx = 10, }) => {
    const { refs, x, y, update, elements: { domReference, floating }, context, } = useFloating({
        placement,
        strategy,
        middleware: [
            offset(offsetInPx),
            shift(),
            flip(),
            size({
                padding: 10,
                apply: ({ availableHeight, elements }) => {
                    Object.assign(elements.floating.style, {
                        maxHeight: `${availableHeight}px`,
                    });
                },
            }),
            ...middleware,
        ],
    });
    // handle window resizing
    useEffect(() => {
        if (!domReference || !floating)
            return;
        const cleanup = autoUpdate(domReference, floating, update);
        return () => cleanup();
    }, [domReference, floating, update]);
    return { refs, x, y, domReference, floating, strategy, context };
};

const defaultDevice = 'default';
/**
 * This hook will apply and persist the device preferences from local storage.
 *
 * @param key the key to use for local storage.
 */
const usePersistedDevicePreferences = (key = '@stream-io/device-preferences') => {
    const { useCallSettings, useCallCallingState, useMicrophoneState, useCameraState, useSpeakerState, } = useCallStateHooks();
    const settings = useCallSettings();
    const callingState = useCallCallingState();
    const microphoneState = useMicrophoneState();
    const cameraState = useCameraState();
    const speakerState = useSpeakerState();
    const [applyingState, setApplyingState] = useState('idle');
    const call = useCall();
    // Set deferServerDefaults flag synchronously during render.
    // Please ensure the flag is set BEFORE any call.get() or call.getOrCreate()
    // is called, preventing server defaults from overriding user preferences.
    const deferredCallRef = useRef(null);
    if (call && deferredCallRef.current !== call) {
        call.camera.deferServerDefaults = true;
        call.microphone.deferServerDefaults = true;
        deferredCallRef.current = call;
    }
    // Cleanup: reset the flag when the component unmounts or call changes.
    // This allows server defaults to apply if the hook is no longer used.
    useEffect(() => {
        return () => {
            const currentCall = deferredCallRef.current;
            if (currentCall) {
                currentCall.camera.deferServerDefaults = false;
                currentCall.microphone.deferServerDefaults = false;
                deferredCallRef.current = null;
            }
        };
    }, [call]);
    // when the camera is disabled on call type level, we should discard
    // any stored camera preferences.
    const cameraDevices = settings?.video?.enabled ? cameraState.devices : false;
    useEffect(function apply() {
        if (callingState === CallingState.LEFT ||
            microphoneState.devices.length === 0 ||
            (Array.isArray(cameraDevices) && cameraDevices.length === 0) ||
            speakerState.devices.length === 0 ||
            !settings ||
            applyingState !== 'idle') {
            return;
        }
        setApplyingState('applying');
        (async () => {
            const { audio, video } = settings;
            for (const [deviceKey, state, defaultMuted, enabledInCallType] of [
                ['microphone', microphoneState, !audio.mic_default_on, true],
                ['camera', cameraState, !video.camera_default_on, video.enabled],
                ['speaker', speakerState, false, true],
            ]) {
                const preferences = parseLocalDevicePreferences(key);
                const preference = preferences[deviceKey];
                const manager = state[deviceKey];
                const applyPromise = preference
                    ? applyLocalDevicePreference(manager, [preference].flat(), deviceKey === 'camera' ? cameraDevices || [] : state.devices, enabledInCallType)
                    : applyMutedState(manager, defaultMuted, enabledInCallType);
                await applyPromise.catch((err) => {
                    console.warn(`Failed to apply ${deviceKey} device preferences`, err);
                });
            }
        })().finally(() => setApplyingState((state) => (state === 'applying' ? 'applied' : state)));
    }, [
        applyingState,
        callingState,
        cameraState,
        cameraDevices,
        key,
        microphoneState,
        microphoneState.devices,
        settings,
        speakerState,
        speakerState.devices,
    ]);
    useEffect(function persist() {
        if (callingState === CallingState.LEFT || applyingState !== 'applied') {
            return;
        }
        for (const [deviceKey, devices, selectedDevice, isMute] of [
            [
                'camera',
                cameraDevices || [],
                cameraState.selectedDevice,
                cameraState.isMute,
            ],
            [
                'microphone',
                microphoneState.devices,
                microphoneState.selectedDevice,
                microphoneState.isMute,
            ],
            [
                'speaker',
                speakerState.devices,
                speakerState.selectedDevice,
                speakerState.isMute,
            ],
        ]) {
            try {
                patchLocalDevicePreference(key, deviceKey, {
                    devices,
                    selectedDevice,
                    isMute,
                });
            }
            catch (err) {
                console.warn(`Failed to save ${deviceKey} device preferences`, err);
            }
        }
    }, [
        applyingState,
        callingState,
        cameraDevices,
        cameraState.isMute,
        cameraState.selectedDevice,
        key,
        microphoneState.devices,
        microphoneState.isMute,
        microphoneState.selectedDevice,
        speakerState.devices,
        speakerState.isMute,
        speakerState.selectedDevice,
    ]);
};
const parseLocalDevicePreferences = (key) => {
    const preferencesStr = window.localStorage.getItem(key);
    let preferences = {};
    if (preferencesStr) {
        try {
            preferences = JSON.parse(preferencesStr);
            if (Object.hasOwn(preferences, 'mic')) {
                // for backwards compatibility
                preferences.microphone = preferences.mic;
            }
        }
        catch {
            /* assume preferences are empty */
        }
    }
    return preferences;
};
const patchLocalDevicePreference = (key, deviceKey, state) => {
    const preferences = parseLocalDevicePreferences(key);
    const nextPreference = getSelectedDevicePreference(state.devices, state.selectedDevice);
    const preferenceHistory = [preferences[deviceKey] ?? []]
        .flat()
        .filter((p) => p.selectedDeviceId !== nextPreference.selectedDeviceId &&
        (p.selectedDeviceLabel === '' ||
            p.selectedDeviceLabel !== nextPreference.selectedDeviceLabel));
    window.localStorage.setItem(key, JSON.stringify({
        ...preferences,
        mic: undefined, // for backwards compatibility
        [deviceKey]: [
            {
                ...nextPreference,
                muted: state.isMute,
            },
            ...preferenceHistory,
        ].slice(0, 3),
    }));
};
const applyLocalDevicePreference = async (manager, preference, devices, enabledInCallType) => {
    let muted;
    for (const p of preference) {
        muted ?? (muted = p.muted);
        if (p.selectedDeviceId === defaultDevice) {
            break;
        }
        const device = devices.find((d) => d.deviceId === p.selectedDeviceId) ??
            devices.find((d) => d.label === p.selectedDeviceLabel);
        if (device) {
            if (!manager.state.selectedDevice) {
                await manager.select(device.deviceId);
            }
            muted = p.muted;
            break;
        }
    }
    if (typeof muted === 'boolean') {
        await applyMutedState(manager, muted, enabledInCallType);
    }
};
const applyMutedState = async (manager, muted, enabledInCallType) => {
    if (enabledInCallType && !manager.state.status) {
        await manager[muted ? 'disable' : 'enable']?.();
    }
};
const getSelectedDevicePreference = (devices, selectedDevice) => ({
    selectedDeviceId: selectedDevice || defaultDevice,
    selectedDeviceLabel: devices?.find((d) => d.deviceId === selectedDevice)?.label ?? '',
});

const SCROLL_THRESHOLD = 10;
/**
 * Hook which observes element's scroll position and returns text value based on the
 * position of the scrollbar (`top`, `bottom`, `between` and `null` if no scrollbar is available)
 */
const useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
    const [scrollPosition, setScrollPosition] = useState(null);
    useEffect(() => {
        if (!scrollElement)
            return;
        const scrollHandler = () => {
            const element = scrollElement;
            const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;
            if (!hasVerticalScrollbar)
                return setScrollPosition(null);
            const isAtTheTop = element.scrollTop <= threshold;
            if (isAtTheTop)
                return setScrollPosition('top');
            const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;
            if (isAtTheBottom)
                return setScrollPosition('bottom');
            setScrollPosition('between');
        };
        const resizeObserver = new ResizeObserver(scrollHandler);
        resizeObserver.observe(scrollElement);
        scrollElement.addEventListener('scroll', scrollHandler);
        return () => {
            scrollElement.removeEventListener('scroll', scrollHandler);
            resizeObserver.disconnect();
        };
    }, [scrollElement, threshold]);
    return scrollPosition;
};
const useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
    const [scrollPosition, setScrollPosition] = useState(null);
    useEffect(() => {
        if (!scrollElement)
            return;
        const scrollHandler = () => {
            const element = scrollElement;
            const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
            if (!hasHorizontalScrollbar)
                return setScrollPosition(null);
            const isAtTheStart = element.scrollLeft <= threshold;
            if (isAtTheStart)
                return setScrollPosition('start');
            const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;
            if (isAtTheEnd)
                return setScrollPosition('end');
            setScrollPosition('between');
        };
        const resizeObserver = new ResizeObserver(scrollHandler);
        resizeObserver.observe(scrollElement);
        scrollElement.addEventListener('scroll', scrollHandler);
        return () => {
            scrollElement.removeEventListener('scroll', scrollHandler);
            resizeObserver.disconnect();
        };
    }, [scrollElement, threshold]);
    return scrollPosition;
};

const useRequestPermission = (permission) => {
    const call = useCall();
    const { useHasPermissions } = useCallStateHooks();
    const hasPermission = useHasPermissions(permission);
    const [isAwaitingPermission, setIsAwaitingPermission] = useState(false); // TODO: load with possibly pending state
    useEffect(() => {
        const reset = () => setIsAwaitingPermission(false);
        if (hasPermission)
            reset();
    }, [hasPermission]);
    const requestPermission = useCallback(async () => {
        if (hasPermission)
            return true;
        const canRequestPermission = !!call?.permissionsContext.canRequest(permission);
        if (isAwaitingPermission || !canRequestPermission)
            return false;
        setIsAwaitingPermission(true);
        try {
            await call?.requestPermissions({
                permissions: [permission],
            });
        }
        catch (error) {
            setIsAwaitingPermission(false);
            throw new Error(`requestPermission failed: ${error}`);
        }
        return false;
    }, [call, hasPermission, isAwaitingPermission, permission]);
    return {
        requestPermission,
        hasPermission,
        canRequestPermission: !!call?.permissionsContext.canRequest(permission),
        isAwaitingPermission,
    };
};

/**
 * Utility hook that helps render a list of devices or implement a device selector.
 * Compared to someting like `useCameraState().devices`, it has some handy features:
 * 1. Adds the "Default" device to the list if applicable (either the user did not
 * select a device, or a previously selected device is no longer available).
 * 2. Maps the device list to a format more suitable for rendering.
 */
function useDeviceList(devices, selectedDeviceId) {
    const { t } = useI18n();
    return useMemo(() => {
        let selectedDeviceInfo = null;
        let selectedIndex = null;
        const deviceList = devices.map((d, i) => {
            const isSelected = d.deviceId === selectedDeviceId;
            const device = { deviceId: d.deviceId, label: d.label, isSelected };
            if (isSelected) {
                selectedDeviceInfo = device;
                selectedIndex = i;
            }
            return device;
        });
        if (selectedDeviceInfo === null || selectedIndex === null) {
            const defaultDevice = {
                deviceId: 'default',
                label: t('Default'),
                isSelected: true,
            };
            selectedDeviceInfo = defaultDevice;
            selectedIndex = 0;
            deviceList.unshift(defaultDevice);
        }
        return { deviceList, selectedDeviceInfo, selectedIndex };
    }, [devices, selectedDeviceId, t]);
}

const isFullScreenBlurPlatformSupported = () => {
    if (typeof window === 'undefined' ||
        typeof OffscreenCanvas === 'undefined' ||
        typeof VideoFrame === 'undefined' ||
        !window.WebGL2RenderingContext) {
        return false;
    }
    try {
        const canvas = new OffscreenCanvas(1, 1);
        return !!canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            desynchronized: true,
        });
    }
    catch {
        return false;
    }
};
const useModeration = (options) => {
    const { duration = 5000 } = options || {};
    const call = useCall();
    const timeoutRef = useRef(null);
    const processorRef = useRef(null);
    const unregisterRef = useRef(null);
    const blurModulePromise = useRef(null);
    /**
     * Lazily loads and caches the video-filters-web module.
     */
    const loadVideoFiltersWebModule = useCallback(() => {
        if (!blurModulePromise.current) {
            blurModulePromise.current = import('@stream-io/video-filters-web')
                .then((module) => module.FullScreenBlur)
                .catch((error) => {
                console.error('[moderation] Failed to import blur module:', error);
                throw error;
            });
        }
        return blurModulePromise.current;
    }, []);
    const disableBlur = useCallback(() => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
        unregisterRef
            .current?.()
            .catch((err) => console.error('[moderation] unregister error:', err));
        unregisterRef.current = null;
    }, []);
    const handleFallback = useCallback(async () => {
        try {
            await call?.camera.disable();
        }
        catch (error) {
            console.error('[moderation] Failed to disable camera:', error);
        }
    }, [call]);
    useEffect(() => {
        if (!call)
            return;
        return call.on('call.moderation_warning', async () => {
            try {
                await loadVideoFiltersWebModule();
            }
            catch (importErr) {
                console.error('[moderation] Failed to import blur module:', importErr);
            }
        });
    }, [call, loadVideoFiltersWebModule]);
    useEffect(() => {
        if (!call)
            return;
        return call.on('call.moderation_blur', async () => {
            if (unregisterRef.current)
                return;
            let FullScreenBlurClass;
            try {
                FullScreenBlurClass = await loadVideoFiltersWebModule();
            }
            catch (importErr) {
                console.error('[moderation] Failed to import blur module:', importErr);
                await handleFallback();
                return;
            }
            if (!isFullScreenBlurPlatformSupported()) {
                console.warn('[moderation] Blur not supported on this platform');
                await handleFallback();
                return;
            }
            const { unregister } = call.camera.registerFilter((inputStream) => {
                unregisterRef.current = unregister;
                const outputPromise = new Promise(async (resolve, reject) => {
                    const [track] = inputStream.getVideoTracks();
                    let processor;
                    try {
                        processor = new FullScreenBlurClass(track);
                        processorRef.current = processor;
                        const result = await processor.start();
                        const output = new MediaStream([result]);
                        resolve(output);
                        if (duration > 0) {
                            timeoutRef.current = setTimeout(disableBlur, duration);
                        }
                    }
                    catch (error) {
                        reject(error);
                        console.error('[moderation] Processor init failed:', error);
                        await unregisterRef.current?.();
                        unregisterRef.current = null;
                        processorRef.current = null;
                        await handleFallback();
                        return;
                    }
                });
                return {
                    output: outputPromise,
                    stop: () => {
                        if (processorRef.current) {
                            processorRef.current.stop();
                            processorRef.current = null;
                        }
                    },
                };
            });
        });
    }, [call, loadVideoFiltersWebModule, disableBlur, handleFallback, duration]);
    useEffect(() => disableBlur, [disableBlur]);
};

/**
 * Enables drag-to-scroll functionality with momentum scrolling on a scrollable element.
 *
 * This hook allows users to click and drag to scroll an element, with momentum scrolling
 * that continues after the drag ends. The drag only activates after moving beyond a threshold
 *  distance, which prevents accidental drags from clicks.
 *
 * @param element - The HTML element to enable drag to scroll on.
 * @param options - Options for customizing the drag-to-scroll behavior.
 */
function useDragToScroll(element, options = {}) {
    const stateRef = useRef({
        isDragging: false,
        isPointerActive: false,
        prevX: 0,
        prevY: 0,
        velocityX: 0,
        velocityY: 0,
        rafId: 0,
        startX: 0,
        startY: 0,
    });
    useEffect(() => {
        if (!element || !options.enabled)
            return;
        const { decay = 0.95, minVelocity = 0.5, dragThreshold = 5 } = options;
        const state = stateRef.current;
        const stopMomentum = () => {
            if (state.rafId) {
                cancelAnimationFrame(state.rafId);
                state.rafId = 0;
            }
            state.velocityX = 0;
            state.velocityY = 0;
        };
        const momentumStep = () => {
            state.velocityX *= decay;
            state.velocityY *= decay;
            element.scrollLeft -= state.velocityX;
            element.scrollTop -= state.velocityY;
            if (Math.abs(state.velocityX) < minVelocity &&
                Math.abs(state.velocityY) < minVelocity) {
                state.rafId = 0;
                return;
            }
            state.rafId = requestAnimationFrame(momentumStep);
        };
        const onPointerDown = (e) => {
            if (e.pointerType !== 'mouse')
                return;
            stopMomentum();
            state.isDragging = false;
            state.isPointerActive = true;
            state.prevX = e.clientX;
            state.prevY = e.clientY;
            state.startX = e.clientX;
            state.startY = e.clientY;
        };
        const onPointerMove = (e) => {
            if (e.pointerType !== 'mouse')
                return;
            if (!state.isPointerActive)
                return;
            const dx = e.clientX - state.startX;
            const dy = e.clientY - state.startY;
            if (!state.isDragging && Math.hypot(dx, dy) > dragThreshold) {
                state.isDragging = true;
                e.preventDefault();
            }
            if (!state.isDragging)
                return;
            const moveDx = e.clientX - state.prevX;
            const moveDy = e.clientY - state.prevY;
            element.scrollLeft -= moveDx;
            element.scrollTop -= moveDy;
            state.velocityX = moveDx;
            state.velocityY = moveDy;
            state.prevX = e.clientX;
            state.prevY = e.clientY;
        };
        const onPointerUpOrCancel = () => {
            const wasDragging = state.isDragging;
            state.isDragging = false;
            state.isPointerActive = false;
            state.prevX = 0;
            state.prevY = 0;
            state.startX = 0;
            state.startY = 0;
            if (!wasDragging) {
                stopMomentum();
                return;
            }
            if (Math.hypot(state.velocityX, state.velocityY) < minVelocity) {
                stopMomentum();
                return;
            }
            state.rafId = requestAnimationFrame(momentumStep);
        };
        element.addEventListener('pointerdown', onPointerDown);
        element.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUpOrCancel);
        window.addEventListener('pointercancel', onPointerUpOrCancel);
        return () => {
            element.removeEventListener('pointerdown', onPointerDown);
            element.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUpOrCancel);
            window.removeEventListener('pointercancel', onPointerUpOrCancel);
            stopMomentum();
        };
    }, [element, options]);
}

var MenuVisualType;
(function (MenuVisualType) {
    MenuVisualType["PORTAL"] = "portal";
    MenuVisualType["MENU"] = "menu";
})(MenuVisualType || (MenuVisualType = {}));
/**
 * Used to provide utility APIs to the components rendered inside the portal.
 */
const MenuContext = createContext({});
/**
 * Access to the closes MenuContext.
 */
const useMenuContext = () => {
    return useContext(MenuContext);
};
const MenuPortal = ({ children, refs, }) => {
    const [portalRoot, setPortalRoot] = useState(null);
    return (jsxs(Fragment, { children: [jsx("div", { ref: setPortalRoot, className: "str-video__portal" }), jsx(FloatingOverlay, { children: jsx(FloatingPortal, { root: portalRoot, children: jsx("div", { className: "str-video__portal-content", ref: refs.setFloating, children: children }) }) })] }));
};
const MenuToggle = ({ ToggleButton, placement = 'top-start', strategy = 'absolute', offset, visualType = MenuVisualType.MENU, children, onToggle, }) => {
    const [menuShown, setMenuShown] = useState(false);
    const toggleHandler = useRef(onToggle);
    toggleHandler.current = onToggle;
    const { floating, domReference, refs, x, y } = useFloatingUIPreset({
        placement,
        strategy,
        offset,
    });
    useEffect(() => {
        const parentDocument = domReference?.ownerDocument;
        const handleClick = (event) => {
            if (!floating && domReference?.contains(event.target)) {
                setMenuShown(true);
                toggleHandler.current?.(true);
            }
            else if (floating && !floating?.contains(event.target)) {
                setMenuShown(false);
                toggleHandler.current?.(false);
            }
        };
        const handleKeyDown = (event) => {
            if (event.key && // key can be undefined in some browsers
                event.key.toLowerCase() === 'escape' &&
                !event.altKey &&
                !event.ctrlKey) {
                setMenuShown(false);
                toggleHandler.current?.(false);
            }
        };
        parentDocument?.addEventListener('click', handleClick, { capture: true });
        parentDocument?.addEventListener('keydown', handleKeyDown);
        return () => {
            parentDocument?.removeEventListener('click', handleClick, {
                capture: true,
            });
            parentDocument?.removeEventListener('keydown', handleKeyDown);
        };
    }, [floating, domReference]);
    return (jsxs(Fragment, { children: [menuShown && (jsx(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? (jsx(MenuPortal, { refs: refs, children: children })) : visualType === MenuVisualType.MENU ? (jsx("div", { className: "str-video__menu-container", ref: refs.setFloating, style: {
                        position: strategy,
                        top: y ?? 0,
                        left: x ?? 0,
                        overflowY: 'auto',
                    }, role: "menu", children: children })) : null })), jsx(ToggleButton, { menuShown: menuShown, ref: refs.setReference })] }));
};

const GenericMenu = ({ children, onItemClick, }) => {
    const ref = useRef(null);
    return (jsx("ul", { className: "str-video__generic-menu", ref: ref, onClick: (e) => {
            if (onItemClick &&
                e.target !== ref.current &&
                ref.current?.contains(e.target)) {
                onItemClick(e);
            }
        }, children: children }));
};
const GenericMenuButtonItem = ({ children, ...rest }) => {
    return (jsx("li", { className: "str-video__generic-menu--item", children: jsx("button", { ...rest, children: children }) }));
};

const Icon = ({ className, icon }) => (jsx("span", { className: clsx('str-video__icon', icon && `str-video__icon--${icon}`, className) }));

function usePictureInPictureState(videoElement) {
    const [isPiP, setIsPiP] = useState(document.pictureInPictureElement === videoElement);
    if (!videoElement && isPiP)
        setIsPiP(false);
    useEffect(() => {
        if (!videoElement)
            return;
        const handlePiP = () => {
            setIsPiP(document.pictureInPictureElement === videoElement);
        };
        videoElement.addEventListener('enterpictureinpicture', handlePiP);
        videoElement.addEventListener('leavepictureinpicture', handlePiP);
        return () => {
            videoElement.removeEventListener('enterpictureinpicture', handlePiP);
            videoElement.removeEventListener('leavepictureinpicture', handlePiP);
        };
    }, [videoElement]);
    return isPiP;
}

const ParticipantActionsContextMenu = () => {
    const { participant, participantViewElement, videoElement } = useParticipantViewContext();
    const [fullscreenModeOn, setFullscreenModeOn] = useState(!!document.fullscreenElement);
    const call = useCall();
    const isPiP = usePictureInPictureState(videoElement ?? undefined);
    const { t } = useI18n();
    const { pin, sessionId, userId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const hasScreenShareTrack = hasScreenShare(participant);
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const blockUser = () => call?.blockUser(userId);
    const kickUser = () => call?.kickUser({ user_id: userId });
    const muteAudio = () => call?.muteUser(userId, 'audio');
    const muteVideo = () => call?.muteUser(userId, 'video');
    const muteScreenShare = () => call?.muteUser(userId, 'screenshare');
    const muteScreenShareAudio = () => call?.muteUser(userId, 'screenshare_audio');
    const grantPermission = (permission) => () => {
        call?.updateUserPermissions({
            user_id: userId,
            grant_permissions: [permission],
        });
    };
    const revokePermission = (permission) => () => {
        call?.updateUserPermissions({
            user_id: userId,
            revoke_permissions: [permission],
        });
    };
    const toggleParticipantPin = () => {
        if (pin) {
            call?.unpin(sessionId);
        }
        else {
            call?.pin(sessionId);
        }
    };
    const pinForEveryone = () => {
        call
            ?.pinForEveryone({ user_id: userId, session_id: sessionId })
            .catch((err) => {
            console.error(`Failed to pin participant ${userId}`, err);
        });
    };
    const unpinForEveryone = () => {
        call
            ?.unpinForEveryone({ user_id: userId, session_id: sessionId })
            .catch((err) => {
            console.error(`Failed to unpin participant ${userId}`, err);
        });
    };
    const toggleFullscreenMode = () => {
        if (!fullscreenModeOn) {
            return participantViewElement?.requestFullscreen().catch(console.error);
        }
        return document.exitFullscreen().catch(console.error);
    };
    useEffect(() => {
        // handles the case when fullscreen mode is toggled externally,
        // e.g., by pressing ESC key or some other keyboard shortcut
        const handleFullscreenChange = () => {
            setFullscreenModeOn(!!document.fullscreenElement);
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        return () => {
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
        };
    }, []);
    const togglePictureInPicture = () => {
        if (videoElement && !isPiP) {
            return videoElement
                .requestPictureInPicture()
                .catch(console.error);
        }
        return document.exitPictureInPicture().catch(console.error);
    };
    const { close } = useMenuContext() || {};
    return (jsxs(GenericMenu, { onItemClick: close, children: [jsxs(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), pin ? t('Unpin') : t('Pin')] }), jsxs(Restricted, { requiredGrants: [OwnCapability.PIN_FOR_EVERYONE], children: [jsxs(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), t('Pin for everyone')] }), jsxs(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), t('Unpin for everyone')] })] }), jsx(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: jsxs(GenericMenuButtonItem, { onClick: blockUser, children: [jsx(Icon, { icon: "not-allowed" }), t('Block')] }) }), jsx(Restricted, { requiredGrants: [OwnCapability.KICK_USER], children: jsxs(GenericMenuButtonItem, { onClick: kickUser, children: [jsx(Icon, { icon: "kick-user" }), t('Kick')] }) }), jsxs(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], children: [hasVideoTrack && (jsxs(GenericMenuButtonItem, { onClick: muteVideo, children: [jsx(Icon, { icon: "camera-off-outline" }), t('Turn off video')] })), hasScreenShareTrack && (jsxs(GenericMenuButtonItem, { onClick: muteScreenShare, children: [jsx(Icon, { icon: "screen-share-off" }), t('Turn off screen share')] })), hasAudioTrack && (jsxs(GenericMenuButtonItem, { onClick: muteAudio, children: [jsx(Icon, { icon: "no-audio" }), t('Mute audio')] })), hasScreenShareAudioTrack && (jsxs(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [jsx(Icon, { icon: "no-audio" }), t('Mute screen share audio')] }))] }), participantViewElement &&
                typeof participantViewElement.requestFullscreen !== 'undefined' && (jsx(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t('{{ direction }} fullscreen', {
                    direction: fullscreenModeOn ? t('Leave') : t('Enter'),
                }) })), videoElement && document.pictureInPictureEnabled && (jsx(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t('{{ direction }} picture-in-picture', {
                    direction: isPiP ? t('Leave') : t('Enter'),
                }) })), jsxs(Restricted, { requiredGrants: [OwnCapability.UPDATE_CALL_PERMISSIONS], children: [jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_AUDIO), children: t('Allow audio') }), jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_VIDEO), children: t('Allow video') }), jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SCREENSHARE), children: t('Allow screen sharing') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_AUDIO), children: t('Disable audio') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_VIDEO), children: t('Disable video') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SCREENSHARE), children: t('Disable screen sharing') })] })] }));
};

const isComponentType = (elementOrComponent) => {
    return elementOrComponent === null
        ? false
        : !isValidElement(elementOrComponent);
};

const chunk = (array, size) => {
    const chunkCount = Math.ceil(array.length / size);
    return Array.from({ length: chunkCount }, (_, index) => array.slice(size * index, size * index + size));
};

const applyElementToRef = (ref, element) => {
    if (!ref)
        return;
    if (typeof ref === 'function')
        return ref(element);
    ref.current = element;
};

/**
 * Normalizes a string for diacritic-insensitive comparison.
 * E.g., "Éva" becomes "eva", allowing "eva" to match "Éva".
 */
const normalizeString = (value) => value
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .toLowerCase();

/**
 * @description Extends video element with `stream` property
 * (`srcObject`) to reactively handle stream changes
 */
const BaseVideo = forwardRef(function BaseVideo({ stream, ...rest }, ref) {
    const [videoElement, setVideoElement] = useState(null);
    useEffect(() => {
        if (!videoElement || !stream)
            return;
        if (stream === videoElement.srcObject)
            return;
        videoElement.srcObject = stream;
        if (Browsers.isSafari() || Browsers.isFirefox()) {
            // Firefox and Safari have some timing issue
            setTimeout(() => {
                videoElement.srcObject = stream;
                videoElement.play().catch((e) => {
                    console.error(`Failed to play stream`, e);
                });
            }, 0);
        }
        return () => {
            videoElement.pause();
            videoElement.srcObject = null;
        };
    }, [stream, videoElement]);
    return (jsx("video", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {
            applyElementToRef(ref, element);
            setVideoElement(element);
        } }));
});

const BaseVideoPlaceholder = forwardRef(function DefaultVideoPlaceholder({ participant, style, children }, ref) {
    const [error, setError] = useState(false);
    const name = participant.name || participant.userId;
    return (jsxs("div", { className: "str-video__video-placeholder", style: style, ref: ref, children: [(!participant.image || error) &&
                (name ? (jsx(InitialsFallback, { name: name })) : (jsx("div", { className: "str-video__video-placeholder__no-video-label", children: children }))), participant.image && !error && (jsx("img", { onError: () => setError(true), alt: name, className: "str-video__video-placeholder__avatar", src: participant.image }))] }));
});
const InitialsFallback = (props) => {
    const { name } = props;
    const initials = name
        .split(' ')
        .slice(0, 2)
        .map((n) => n[0])
        .join('');
    return (jsx("div", { className: "str-video__video-placeholder__initials-fallback", children: initials }));
};

const DefaultVideoPlaceholder = forwardRef(function DefaultVideoPlaceholder(props, ref) {
    const { t } = useI18n();
    return (jsx(BaseVideoPlaceholder, { ref: ref, ...props, children: t('Video is disabled') }));
});

const DefaultPictureInPicturePlaceholder = forwardRef(function DefaultPictureInPicturePlaceholder(props, ref) {
    const { t } = useI18n();
    return (jsx(BaseVideoPlaceholder, { ref: ref, ...props, children: t('Video is playing in a popup') }));
});

const Video$1 = ({ enabled = true, mirror, trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder, PictureInPicturePlaceholder = DefaultPictureInPicturePlaceholder, refs, ...rest }) => {
    const { sessionId, videoStream, screenShareStream, viewportVisibilityState, isLocalParticipant, userId, } = participant;
    const call = useCall();
    const [videoElement, setVideoElement] = useState(null);
    // start with true, will flip once the video starts playing
    const [isVideoPaused, setIsVideoPaused] = useState(true);
    const [isWideMode, setIsWideMode] = useState(true);
    const isPiP = usePictureInPictureState(videoElement ?? undefined);
    const stream = trackType === 'videoTrack'
        ? videoStream
        : trackType === 'screenShareTrack'
            ? screenShareStream
            : undefined;
    useLayoutEffect(() => {
        if (!call || !videoElement || trackType === 'none')
            return;
        const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);
        return () => {
            cleanup?.();
        };
    }, [call, trackType, sessionId, videoElement]);
    useEffect(() => {
        if (!stream || !videoElement)
            return;
        const [track] = stream.getVideoTracks();
        if (!track)
            return;
        const handlePlayPause = () => {
            setIsVideoPaused(videoElement.paused);
            const { width = 0, height = 0 } = track.getSettings();
            setIsWideMode(width >= height);
        };
        // playback may have started before we had a chance to
        // attach the 'play/pause' event listener, so we set the state
        // here to make sure it's in sync
        setIsVideoPaused(videoElement.paused);
        videoElement.addEventListener('play', handlePlayPause);
        videoElement.addEventListener('pause', handlePlayPause);
        track.addEventListener('unmute', handlePlayPause);
        return () => {
            videoElement.removeEventListener('play', handlePlayPause);
            videoElement.removeEventListener('pause', handlePlayPause);
            track.removeEventListener('unmute', handlePlayPause);
            // reset the 'pause' state once we unmount the video element
            setIsVideoPaused(true);
        };
    }, [stream, videoElement]);
    if (!call)
        return null;
    const isPublishingTrack = trackType === 'videoTrack'
        ? hasVideo(participant)
        : trackType === 'screenShareTrack'
            ? hasScreenShare(participant)
            : false;
    const isInvisible = trackType === 'none' ||
        viewportVisibilityState?.[trackType] === VisibilityState.INVISIBLE;
    const hasNoVideoOrInvisible = !enabled ||
        !isPublishingTrack ||
        isInvisible ||
        hasPausedTrack(participant, trackType);
    const mirrorVideo = mirror === undefined
        ? isLocalParticipant && trackType === 'videoTrack'
        : mirror;
    const isScreenShareTrack = trackType === 'screenShareTrack';
    return (jsxs(Fragment, { children: [!hasNoVideoOrInvisible && (jsx("video", { ...rest, className: clsx('str-video__video', className, {
                    'str-video__video--not-playing': isVideoPaused,
                    'str-video__video--tall': !isWideMode,
                    'str-video__video--mirror': mirrorVideo,
                    'str-video__video--screen-share': isScreenShareTrack,
                }), "data-user-id": userId, "data-session-id": sessionId, ref: (element) => {
                    setVideoElement(element);
                    refs?.setVideoElement?.(element);
                } })), isPiP && PictureInPicturePlaceholder && (jsx(PictureInPicturePlaceholder, { style: { position: 'absolute' }, participant: participant })), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && (jsx(VideoPlaceholder, { style: { position: 'absolute' }, participant: participant, ref: refs?.setVideoPlaceholderElement }))] }));
};
Video$1.displayName = 'Video';

const useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType, }) => {
    const call = useCall();
    const manager = propsDynascaleManager ?? call?.dynascaleManager;
    useEffect(() => {
        if (!trackedElement || !manager || !call || trackType === 'none')
            return;
        const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);
        return () => {
            unobserve();
        };
    }, [trackedElement, manager, call, sessionId, trackType]);
};

const Avatar = ({ imageSrc, name, style, className, ...rest }) => {
    const [error, setError] = useState(false);
    return (jsxs(Fragment, { children: [(!imageSrc || error) && name && (jsx(AvatarFallback, { className: className, style: style, names: [name] })), imageSrc && !error && (jsx("img", { onError: () => setError(true), alt: "avatar", className: clsx('str-video__avatar', className), src: imageSrc, style: style, ...rest }))] }));
};
const AvatarFallback = ({ className, names, style, }) => {
    return (jsx("div", { className: clsx('str-video__avatar--initials-fallback', className), style: style, children: jsxs("div", { children: [names[0][0], names[1]?.[0]] }) }));
};

const BackgroundFiltersProviderImpl = lazy(() => import('./background-filters-RdXfNf6_.es.js').then((m) => ({
    default: m.BackgroundFiltersProvider,
})));
/**
 * The context for the background filters.
 */
const BackgroundFiltersContext = createContext(undefined);
/**
 * A hook to access the background filters context API.
 */
const useBackgroundFilters = () => {
    const context = useContext(BackgroundFiltersContext);
    if (!context) {
        throw new Error('useBackgroundFilters must be used within a BackgroundFiltersProvider');
    }
    return context;
};
/**
 * A provider component that enables the use of background filters in your app.
 *
 * Please make sure you have the `@stream-io/video-filters-web` package installed
 * in your project before using this component.
 */
const BackgroundFiltersProvider = (props) => {
    const { SuspenseFallback = null, ...filterProps } = props;
    return (jsx(Suspense, { fallback: SuspenseFallback, children: jsx(BackgroundFiltersProviderImpl, { ...filterProps, ContextProvider: BackgroundFiltersContext }) }));
};

const IconButton = forwardRef(function IconButton(props, ref) {
    const { icon, enabled, variant, onClick, className, ...rest } = props;
    return (jsx("button", { className: clsx('str-video__call-controls__button', className, {
            [`str-video__call-controls__button--variant-${variant}`]: variant,
            'str-video__call-controls__button--enabled': enabled,
        }), onClick: (e) => {
            e.preventDefault();
            onClick?.(e);
        }, ref: ref, ...rest, children: jsx(Icon, { icon: icon }) }));
});

const CompositeButton = forwardRef(function CompositeButton({ disabled, caption, children, className, active, Menu, menuPlacement, menuOffset, title, ToggleMenuButton = DefaultToggleMenuButton, variant, onClick, onMenuToggle, ...restButtonProps }, ref) {
    return (jsxs("div", { className: clsx('str-video__composite-button', className, {
            'str-video__composite-button--caption': caption,
            'str-video__composite-button--menu': Menu,
        }), title: title, ref: ref, children: [jsxs("div", { className: clsx('str-video__composite-button__button-group', {
                    'str-video__composite-button__button-group--active': active,
                    'str-video__composite-button__button-group--active-primary': active && variant === 'primary',
                    'str-video__composite-button__button-group--active-secondary': active && variant === 'secondary',
                    'str-video__composite-button__button-group--disabled': disabled,
                }), children: [jsx("button", { type: "button", className: "str-video__composite-button__button", onClick: (e) => {
                            e.preventDefault();
                            onClick?.(e);
                        }, disabled: disabled, ...restButtonProps, children: children }), Menu && (jsx(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton, onToggle: onMenuToggle, children: isComponentType(Menu) ? jsx(Menu, {}) : Menu }))] }), caption && (jsx("div", { className: "str-video__composite-button__caption", children: caption }))] }));
});
const DefaultToggleMenuButton = forwardRef(function DefaultToggleMenuButton({ menuShown }, ref) {
    return (jsx(IconButton, { className: clsx('str-video__menu-toggle-button', {
            'str-video__menu-toggle-button--active': menuShown,
        }), icon: menuShown ? 'caret-down' : 'caret-up', ref: ref }));
});

const TextButton = ({ children, ...rest }) => {
    return (jsx("button", { ...rest, className: "str-video__text-button", children: children }));
};

const AcceptCallButton = ({ disabled, onAccept, onClick, }) => {
    const call = useCall();
    const handleClick = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.join();
            onAccept?.();
        }
    }, [onClick, onAccept, call]);
    return (jsx(IconButton, { disabled: disabled, icon: "call-accept", variant: "success", "data-testid": "accept-call-button", onClick: handleClick }));
};

const Notification = (props) => {
    const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = 'top', className, iconClassName = 'str-video__notification__icon', close, } = props;
    const { refs, x, y, strategy } = useFloatingUIPreset({
        placement,
        strategy: 'absolute',
    });
    useEffect(() => {
        if (!isVisible || !visibilityTimeout || !resetIsVisible)
            return;
        const timeout = setTimeout(() => {
            resetIsVisible();
        }, visibilityTimeout);
        return () => clearTimeout(timeout);
    }, [isVisible, resetIsVisible, visibilityTimeout]);
    return (jsxs("div", { className: "str-video__notification-wrapper", ref: refs.setReference, children: [isVisible && (jsxs("div", { className: clsx('str-video__notification', className), ref: refs.setFloating, style: {
                    position: strategy,
                    top: y ?? 0,
                    left: x ?? 0,
                    overflowY: 'auto',
                }, children: [iconClassName && jsx("i", { className: iconClassName }), jsx("span", { className: "str-video__notification__message", children: message }), close ? (jsx("i", { className: "str-video__icon str-video__icon--close str-video__notification__close", onClick: close })) : null] })), children] }));
};

const PermissionNotification = (props) => {
    const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children, } = props;
    const { useHasPermissions } = useCallStateHooks();
    const hasPermission = useHasPermissions(permission);
    const prevHasPermission = useRef(hasPermission);
    const [showNotification, setShowNotification] = useState();
    useEffect(() => {
        if (prevHasPermission.current === hasPermission)
            return;
        if (hasPermission) {
            setShowNotification('granted');
            prevHasPermission.current = true;
        }
        else {
            setShowNotification('revoked');
            prevHasPermission.current = false;
        }
    }, [hasPermission]);
    const resetIsVisible = useCallback(() => setShowNotification(undefined), []);
    if (isAwaitingApproval) {
        return (jsx(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children: children }));
    }
    return (jsx(Notification, { isVisible: !!showNotification, visibilityTimeout: visibilityTimeout, resetIsVisible: resetIsVisible, message: showNotification === 'granted' ? messageApproved : messageRevoked, children: children }));
};

const SpeakingWhileMutedNotification = ({ children, text, placement, }) => {
    const { useMicrophoneState } = useCallStateHooks();
    const { isSpeakingWhileMuted } = useMicrophoneState();
    const { t } = useI18n();
    const message = text ?? t('You are muted. Unmute to speak.');
    return (jsx(Notification, { message: message, isVisible: isSpeakingWhileMuted, placement: placement || 'top-start', children: children }));
};

const RecordingInProgressNotification = ({ children, text, }) => {
    const { t } = useI18n();
    const { isCallRecordingInProgress } = useToggleCallRecording();
    const [isVisible, setVisible] = useState(false);
    const message = text ?? t('Recording in progress...');
    useEffect(() => {
        if (isCallRecordingInProgress) {
            setVisible(true);
        }
        else {
            setVisible(false);
        }
    }, [isCallRecordingInProgress]);
    return (jsx(Notification, { message: message, iconClassName: "str-video__icon str-video__icon--recording-on", isVisible: isVisible, placement: "top-start", close: () => setVisible(false), children: children }));
};

const MicCaptureErrorNotification = ({ children, text, placement, }) => {
    const call = useCall();
    const { t } = useI18n();
    const [isVisible, setIsVisible] = useState(false);
    useEffect(() => {
        if (!call)
            return;
        return call.on('mic.capture_report', (event) => {
            setIsVisible(!event.capturesAudio);
        });
    }, [call]);
    const message = text ??
        t('Your microphone is not capturing audio. Please check your setup.');
    return (jsx(Notification, { message: message, isVisible: isVisible, placement: placement, close: () => setIsVisible(false), children: children }));
};

const LoadingIndicator = ({ className, type = 'spinner', text, tooltip, }) => {
    return (jsxs("div", { className: clsx('str-video__loading-indicator', className), title: tooltip, children: [jsx("div", { className: clsx('str-video__loading-indicator__icon', type) }), text && jsx("p", { className: "str-video__loading-indicator-text", children: text })] }));
};

const Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = 'top', visible = false, }) => {
    const arrowRef = useRef(null);
    const { refs, x, y, strategy, context } = useFloatingUIPreset({
        placement: tooltipPlacement,
        strategy: 'absolute',
        middleware: [arrow({ element: arrowRef })],
    });
    useEffect(() => {
        refs.setReference(referenceElement);
    }, [referenceElement, refs]);
    if (!visible)
        return null;
    return (jsxs("div", { className: clsx('str-video__tooltip', tooltipClassName), ref: refs.setFloating, style: {
            position: strategy,
            top: y ?? 0,
            left: x ?? 0,
        }, children: [jsx(FloatingArrow, { ref: arrowRef, context: context, fill: "var(--str-video__tooltip--background-color)" }), children] }));
};

const useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave, } = {}) => {
    const [tooltipVisible, setTooltipVisible] = useState(false);
    const handleMouseEnter = useCallback((e) => {
        setTooltipVisible(true);
        onMouseEnter?.(e);
    }, [onMouseEnter]);
    const handleMouseLeave = useCallback((e) => {
        setTooltipVisible(false);
        onMouseLeave?.(e);
    }, [onMouseLeave]);
    return { handleMouseEnter, handleMouseLeave, tooltipVisible };
};

// todo: duplicate of CallParticipantList.tsx#MediaIndicator - refactor to a single component
const WithTooltip = ({ title, tooltipClassName, tooltipPlacement, tooltipDisabled, ...props }) => {
    const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();
    const [tooltipAnchor, setTooltipAnchor] = useState(null);
    const tooltipActuallyVisible = !tooltipDisabled && Boolean(title) && tooltipVisible;
    return (jsxs(Fragment, { children: [jsx(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipActuallyVisible, tooltipClassName: tooltipClassName, tooltipPlacement: tooltipPlacement, children: title || '' }), jsx("div", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] }));
};

const RecordEndConfirmation = () => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();
    const { close } = useMenuContext();
    return (jsxs("div", { className: "str-video__end-recording__confirmation", children: [jsxs("div", { className: "str-video__end-recording__header", children: [jsx(Icon, { icon: "recording-on" }), jsx("h2", { className: "str-video__end-recording__heading", children: t('End recording') })] }), jsx("p", { className: "str-video__end-recording__description", children: t('Are you sure you want end the recording?') }), jsxs("div", { className: "str-video__end-recording__actions", children: [jsx(CompositeButton, { variant: "secondary", onClick: close, children: t('Cancel') }), jsx(CompositeButton, { variant: "primary", onClick: toggleCallRecording, children: isAwaitingResponse ? jsx(LoadingIndicator, {}) : t('End recording') })] })] }));
};
const ToggleEndRecordingMenuButton = forwardRef(function ToggleEndRecordingMenuButton(props, ref) {
    return (jsx(CompositeButton, { ref: ref, active: true, variant: "secondary", "data-testid": "recording-stop-button", children: jsx(Icon, { icon: "recording-off" }) }));
});
const RecordCallConfirmationButton = ({ caption, }) => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
    if (isCallRecordingInProgress) {
        return (jsx(Restricted, { requiredGrants: [
                OwnCapability.START_RECORD_CALL,
                OwnCapability.STOP_RECORD_CALL,
            ], children: jsx(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: jsx(RecordEndConfirmation, {}) }) }));
    }
    const title = isAwaitingResponse
        ? t('Waiting for recording to start...')
        : (caption ?? t('Record call'));
    return (jsx(Restricted, { requiredGrants: [
            OwnCapability.START_RECORD_CALL,
            OwnCapability.STOP_RECORD_CALL,
        ], children: jsx(WithTooltip, { title: title, children: jsx(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: "secondary", "data-testid": "recording-start-button", onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? (jsx(LoadingIndicator, {})) : (jsx(Icon, { icon: "recording-off" })) }) }) }));
};
const RecordCallButton = ({ caption }) => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
    let title = caption ?? t('Record call');
    if (isAwaitingResponse) {
        title = isCallRecordingInProgress
            ? t('Waiting for recording to stop...')
            : t('Waiting for recording to start...');
    }
    return (jsx(Restricted, { requiredGrants: [
            OwnCapability.START_RECORD_CALL,
            OwnCapability.STOP_RECORD_CALL,
        ], children: jsx(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: "secondary", "data-testid": isCallRecordingInProgress
                ? 'recording-stop-button'
                : 'recording-start-button', title: title, onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? (jsx(LoadingIndicator, {})) : (jsx(Icon, { icon: isCallRecordingInProgress ? 'recording-on' : 'recording-off' })) }) }));
};

const defaultEmojiReactionMap = {
    ':like:': '👍',
    ':raise-hand:': '✋',
    ':fireworks:': '🎉',
    ':dislike:': '👎',
    ':heart:': '❤️',
    ':smile:': '😀',
};
const Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap, }) => {
    const call = useCall();
    useEffect(() => {
        if (!call || !reaction)
            return;
        const timeoutId = setTimeout(() => {
            call.resetReaction(sessionId);
        }, hideAfterTimeoutInMs);
        return () => {
            clearTimeout(timeoutId);
        };
    }, [call, hideAfterTimeoutInMs, reaction, sessionId]);
    if (!reaction)
        return null;
    const { emoji_code: emojiCode } = reaction;
    return (jsx("div", { className: "str-video__reaction", children: jsx("span", { className: "str-video__reaction__emoji", children: emojiCode && emojiReactionMap[emojiCode] }) }));
};

const defaultReactions = [
    {
        type: 'reaction',
        emoji_code: ':like:',
    },
    {
        // TODO OL: use `prompt` type?
        type: 'raised-hand',
        emoji_code: ':raise-hand:',
    },
    {
        type: 'reaction',
        emoji_code: ':fireworks:',
    },
    {
        type: 'reaction',
        emoji_code: ':dislike:',
    },
    {
        type: 'reaction',
        emoji_code: ':heart:',
    },
    {
        type: 'reaction',
        emoji_code: ':smile:',
    },
];
const ReactionsButton = ({ reactions = defaultReactions, }) => {
    return (jsx(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: jsx(MenuToggle, { placement: "top", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: jsx(DefaultReactionsMenu, { reactions: reactions }) }) }));
};
const ToggleReactionsMenuButton = forwardRef(function ToggleReactionsMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(WithTooltip, { title: t('Reactions'), tooltipDisabled: menuShown, children: jsx(CompositeButton, { ref: ref, active: menuShown, variant: "primary", children: jsx(Icon, { icon: "reactions" }) }) }));
});
const DefaultReactionsMenu = ({ reactions, layout = 'horizontal', }) => {
    const call = useCall();
    const { close } = useMenuContext();
    return (jsx("div", { className: clsx('str-video__reactions-menu', {
            'str-video__reactions-menu--horizontal': layout === 'horizontal',
            'str-video__reactions-menu--vertical': layout === 'vertical',
        }), children: reactions.map((reaction) => (jsx("button", { type: "button", className: "str-video__reactions-menu__button", onClick: () => {
                call?.sendReaction(reaction);
                close?.();
            }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code))) }));
};

/**
 * Wraps an event handler, silencing and logging exceptions (excluding the NotAllowedError
 * DOMException, which is a normal situation handled by the SDK)
 *
 * @param props component props, including the onError callback
 * @param handler event handler to wrap
 */
const createCallControlHandler = (props, handler) => {
    return async () => {
        try {
            await handler();
        }
        catch (error) {
            if (props.onError) {
                props.onError(error);
                return;
            }
            if (!isNotAllowedError(error)) {
                console.error('Call control handler failed', error);
            }
        }
    };
};
function isNotAllowedError(error) {
    return error instanceof DOMException && error.name === 'NotAllowedError';
}

const ScreenShareButton = (props) => {
    const { t } = useI18n();
    const { caption, optimisticUpdates } = props;
    const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = useCallStateHooks();
    const isSomeoneScreenSharing = useHasOngoingScreenShare();
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SCREENSHARE);
    const callSettings = useCallSettings();
    const isScreenSharingAllowed = callSettings?.screensharing.enabled;
    const { screenShare, optionsAwareIsMute, isTogglePending } = useScreenShareState({
        optimisticUpdates,
    });
    const amIScreenSharing = !optionsAwareIsMute;
    const disableScreenShareButton = (!amIScreenSharing &&
        (isSomeoneScreenSharing || isScreenSharingAllowed === false)) ||
        (!optimisticUpdates && isTogglePending);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await screenShare.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: jsx(PermissionNotification, { permission: OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your screen.'), messageAwaitingApproval: t('Awaiting for an approval to share screen.'), messageRevoked: t('You can no longer share your screen.'), children: jsx(WithTooltip, { title: caption ?? t('Share screen'), children: jsx(CompositeButton, { active: isSomeoneScreenSharing || amIScreenSharing, caption: caption, variant: "primary", "data-testid": isSomeoneScreenSharing
                        ? 'screen-share-stop-button'
                        : 'screen-share-start-button', disabled: disableScreenShareButton, onClick: handleClick, children: jsx(Icon, { icon: isSomeoneScreenSharing ? 'screen-share-on' : 'screen-share-off' }) }) }) }) }));
};

const AudioVolumeIndicator = () => {
    const { useMicrophoneState } = useCallStateHooks();
    const { isEnabled, mediaStream } = useMicrophoneState();
    const [audioLevel, setAudioLevel] = useState(0);
    useEffect(() => {
        if (!isEnabled || !mediaStream)
            return;
        const disposeSoundDetector = createSoundDetector(mediaStream, ({ audioLevel: al }) => setAudioLevel(al), { detectionFrequencyInMs: 80, destroyStreamOnStop: false });
        return () => {
            disposeSoundDetector().catch(console.error);
        };
    }, [isEnabled, mediaStream]);
    return (jsxs("div", { className: "str-video__audio-volume-indicator", children: [jsx(Icon, { icon: isEnabled ? 'mic' : 'mic-off' }), jsx("div", { className: "str-video__audio-volume-indicator__bar", children: jsx("div", { className: "str-video__audio-volume-indicator__bar-value", style: { transform: `scaleX(${audioLevel / 100})` } }) })] }));
};

const SelectContext = createContext({});
const Select = (props) => {
    const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp, } = props;
    const [isOpen, setIsOpen] = useState(false);
    const [activeIndex, setActiveIndex] = useState(null);
    const [selectedIndex, setSelectedIndex] = useState(defaultSelectedIndex);
    const [selectedLabel, setSelectedLabel] = useState(defaultSelectedLabel);
    const { refs, context } = useFloating({
        placement: 'bottom-start',
        open: isOpen,
        onOpenChange: setIsOpen,
        whileElementsMounted: autoUpdate,
        middleware: [flip()],
    });
    const elementsRef = useRef([]);
    const labelsRef = useRef([]);
    const handleSelect = useCallback((index) => {
        setSelectedIndex(index);
        handleSelectProp(index || 0);
        setIsOpen(false);
        if (index !== null) {
            setSelectedLabel(labelsRef.current[index]);
        }
    }, [handleSelectProp]);
    const handleTypeaheadMatch = (index) => {
        if (isOpen) {
            setActiveIndex(index);
        }
        else {
            handleSelect(index);
        }
    };
    const listNav = useListNavigation(context, {
        listRef: elementsRef,
        activeIndex,
        selectedIndex,
        onNavigate: setActiveIndex,
    });
    const typeahead = useTypeahead(context, {
        listRef: labelsRef,
        activeIndex,
        selectedIndex,
        onMatch: handleTypeaheadMatch,
    });
    const click = useClick(context);
    const dismiss = useDismiss(context);
    const role = useRole(context, { role: 'listbox' });
    const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([listNav, typeahead, click, dismiss, role]);
    const selectContext = useMemo(() => ({
        activeIndex,
        selectedIndex,
        getItemProps,
        handleSelect,
    }), [activeIndex, selectedIndex, getItemProps, handleSelect]);
    return (jsxs("div", { className: "str-video__dropdown", children: [jsxs("div", { className: "str-video__dropdown-selected", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [jsxs("label", { className: "str-video__dropdown-selected__label", children: [icon && (jsx(Icon, { className: "str-video__dropdown-selected__icon", icon: icon })), selectedLabel] }), jsx(Icon, { className: "str-video__dropdown-selected__chevron", icon: isOpen ? 'chevron-up' : 'chevron-down' })] }), jsx(SelectContext.Provider, { value: selectContext, children: isOpen && (jsx(FloatingFocusManager, { context: context, modal: false, children: jsx("div", { className: "str-video__dropdown-list", ref: refs.setFloating, ...getFloatingProps(), children: jsx(FloatingList, { elementsRef: elementsRef, labelsRef: labelsRef, children: children }) }) })) })] }));
};
const DropDownSelectOption = (props) => {
    const { selected, label, icon } = props;
    const { getItemProps, handleSelect } = useContext(SelectContext);
    const { ref, index } = useListItem();
    return (jsxs("div", { className: clsx('str-video__dropdown-option', {
            'str-video__dropdown-option--selected': selected,
        }), ref: ref, ...getItemProps({
            onClick: () => handleSelect(index),
        }), children: [icon && jsx(Icon, { className: "str-video__dropdown-icon", icon: icon }), jsx("span", { className: "str-video__dropdown-label", children: label })] }));
};
const DropDownSelect = (props) => {
    const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex, } = props;
    return (jsx(Select, { icon: icon, handleSelect: handleSelect, defaultSelectedIndex: defaultSelectedIndex, defaultSelectedLabel: defaultSelectedLabel, children: children }));
};

const DeviceSelectorOption = ({ disabled, id, label, onChange, name, selected, defaultChecked, value, }) => {
    return (jsxs("label", { className: clsx('str-video__device-settings__option', {
            'str-video__device-settings__option--selected': selected,
            'str-video__device-settings__option--disabled': disabled,
        }), htmlFor: id, children: [jsx("input", { type: "radio", name: name, onChange: onChange, value: value, id: id, checked: selected, defaultChecked: defaultChecked, disabled: disabled }), label] }));
};
const DeviceSelectorList = (props) => {
    const { devices = [], selectedDeviceId, title, type, onChange, children, } = props;
    const { close } = useMenuContext();
    const { deviceList } = useDeviceList(devices, selectedDeviceId);
    return (jsxs("div", { className: "str-video__device-settings__device-kind", children: [title && (jsx("div", { className: "str-video__device-settings__device-selector-title", children: title })), deviceList.map((device) => {
                return (jsx(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {
                        const deviceId = e.target.value;
                        if (deviceId !== 'default') {
                            onChange?.(deviceId);
                        }
                        close?.();
                    }, name: type, selected: device.isSelected }, device.deviceId));
            }), children] }));
};
const DeviceSelectorDropdown = (props) => {
    const { devices = [], selectedDeviceId, title, onChange, icon } = props;
    const { deviceList, selectedDeviceInfo, selectedIndex } = useDeviceList(devices, selectedDeviceId);
    const handleSelect = useCallback((index) => {
        const deviceId = deviceList[index].deviceId;
        if (deviceId !== 'default') {
            onChange?.(deviceId);
        }
    }, [deviceList, onChange]);
    return (jsxs("div", { className: "str-video__device-settings__device-kind", children: [jsx("div", { className: "str-video__device-settings__device-selector-title", children: title }), jsx(DropDownSelect, { icon: icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: selectedDeviceInfo.label, handleSelect: handleSelect, children: deviceList.map((device) => (jsx(DropDownSelectOption, { icon: icon, label: device.label, selected: device.isSelected }, device.deviceId))) })] }));
};
const DeviceSelector = (props) => {
    const { visualType = 'list', icon, ...rest } = props;
    if (visualType === 'list') {
        return jsx(DeviceSelectorList, { ...rest });
    }
    return jsx(DeviceSelectorDropdown, { ...rest, icon: icon });
};

/**
 * SpeakerTest component that plays a test audio through the selected speaker.
 * This allows users to verify their audio output device is working correctly.
 */
const SpeakerTest = (props) => {
    const { useSpeakerState } = useCallStateHooks();
    const { selectedDevice } = useSpeakerState();
    const audioElementRef = useRef(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const { t } = useI18n();
    const { audioUrl = `https://unpkg.com/${"@stream-io/video-react-sdk"}@${"1.32.1"}/assets/piano.mp3`, } = props;
    // Update audio output device when selection changes
    useEffect(() => {
        const audio = audioElementRef.current;
        if (!audio || !selectedDevice)
            return;
        // Set the sinkId to route audio to the selected speaker
        if ('setSinkId' in audio) {
            audio.setSinkId(selectedDevice).catch((err) => {
                console.error('Failed to set audio output device:', err);
            });
        }
    }, [selectedDevice]);
    const handleStartTest = useCallback(async () => {
        const audio = audioElementRef.current;
        if (!audio)
            return;
        audio.src = audioUrl;
        try {
            if (isPlaying) {
                audio.pause();
                audio.currentTime = 0;
                setIsPlaying(false);
            }
            else {
                await audio.play();
                setIsPlaying(true);
            }
        }
        catch (err) {
            console.error('Failed to play test audio:', err);
            setIsPlaying(false);
        }
    }, [isPlaying, audioUrl]);
    const handleAudioEnded = useCallback(() => setIsPlaying(false), []);
    return (jsxs("div", { className: "str-video__speaker-test", children: [jsx("audio", { ref: audioElementRef, onEnded: handleAudioEnded, onPause: handleAudioEnded }), jsx(CompositeButton, { className: "str-video__speaker-test__button", onClick: handleStartTest, type: "button", children: jsxs("div", { className: "str-video__speaker-test__button-content", children: [jsx(Icon, { icon: "speaker" }), isPlaying ? t('Stop test') : t('Test speaker')] }) })] }));
};

const DeviceSelectorAudioInput = ({ title, visualType, volumeIndicatorVisible = true, }) => {
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, selectedDevice, devices } = useMicrophoneState();
    return (jsx(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: "audioinput", onChange: async (deviceId) => {
            await microphone.select(deviceId);
        }, title: title, visualType: visualType, icon: "mic", children: volumeIndicatorVisible && (jsxs(Fragment, { children: [jsx("hr", { className: "str-video__device-settings__separator" }), jsx(AudioVolumeIndicator, {})] })) }));
};
const DeviceSelectorAudioOutput = ({ title, visualType, speakerTestVisible = true, speakerTestAudioUrl, }) => {
    const { useSpeakerState } = useCallStateHooks();
    const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();
    if (!isDeviceSelectionSupported)
        return null;
    return (jsx(DeviceSelector, { devices: devices, type: "audiooutput", selectedDeviceId: selectedDevice, onChange: (deviceId) => {
            speaker.select(deviceId);
        }, title: title, visualType: visualType, icon: "speaker", children: speakerTestVisible && (jsxs(Fragment, { children: [jsx("hr", { className: "str-video__device-settings__separator" }), jsx(SpeakerTest, { audioUrl: speakerTestAudioUrl })] })) }));
};

const DeviceSelectorVideo = ({ title, visualType, }) => {
    const { useCameraState } = useCallStateHooks();
    const { camera, devices, selectedDevice } = useCameraState();
    return (jsx(DeviceSelector, { devices: devices || [], type: "videoinput", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {
            await camera.select(deviceId);
        }, title: title, visualType: visualType, icon: "camera" }));
};

const DeviceSettings = ({ visualType = MenuVisualType.MENU, }) => {
    return (jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleDeviceSettingsMenuButton, visualType: visualType, children: jsx(Menu, {}) }));
};
const Menu = () => {
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__device-settings", children: [jsx(DeviceSelectorVideo, { title: t('Select a Camera') }), jsx(DeviceSelectorAudioInput, { title: t('Select a Mic') }), jsx(DeviceSelectorAudioOutput, { title: t('Select Speakers') })] }));
};
const ToggleDeviceSettingsMenuButton = forwardRef(function ToggleDeviceSettingsMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(IconButton, { className: clsx('str-video__device-settings__button', {
            'str-video__device-settings__button--active': menuShown,
        }), title: t('Toggle device menu'), icon: "device-settings", ref: ref }));
});

const ToggleAudioPreviewButton = (props) => {
    const { caption, Menu = DeviceSelectorAudioInput, menuPlacement = 'top', onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
    const { t } = useI18n();
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, hasBrowserPermission, isPromptingPermission, optionsAwareIsMute, isTogglePending, } = useMicrophoneState({ optimisticUpdates });
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, () => microphone.toggle());
    return (jsx(WithTooltip, { title: !hasBrowserPermission
            ? t('Check your browser audio permissions')
            : (caption ?? t('Mic')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optionsAwareIsMute, caption: caption, className: clsx(!hasBrowserPermission && 'str-video__device-unavailable'), variant: "secondary", disabled: !hasBrowserPermission || (!optimisticUpdates && isTogglePending), "data-testid": optionsAwareIsMute
                ? 'preview-audio-unmute-button'
                : 'preview-audio-mute-button', onClick: handleClick, Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: [jsx(Icon, { icon: !optionsAwareIsMute ? 'mic' : 'mic-off' }), !hasBrowserPermission && (jsx("span", { className: "str-video__no-media-permission", title: t('Check your browser audio permissions'), children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }));
};
const ToggleAudioPublishingButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = jsx(DeviceSelectorAudioInput, { visualType: "list" }), menuPlacement = 'top', onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_AUDIO);
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute, } = useMicrophoneState({ optimisticUpdates });
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await microphone.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: jsx(PermissionNotification, { permission: OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now speak.'), messageAwaitingApproval: t('Awaiting for an approval to speak.'), messageRevoked: t('You can no longer speak.'), children: jsx(WithTooltip, { title: !hasPermission
                    ? t('You have no permission to share your audio')
                    : !hasBrowserPermission
                        ? t('Check your browser mic permissions')
                        : (caption ?? t('Mic')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optionsAwareIsMute, caption: caption, variant: "secondary", disabled: !hasBrowserPermission ||
                        !hasPermission ||
                        // disable button while the toggle action is pending when not using optimistic updates
                        (!optimisticUpdates && isTogglePending), "data-testid": optionsAwareIsMute ? 'audio-unmute-button' : 'audio-mute-button', onClick: handleClick, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                        setTooltipDisabled(shown);
                        onMenuToggle?.(shown);
                    }, children: [jsx(Icon, { icon: optionsAwareIsMute ? 'mic-off' : 'mic' }), (!hasBrowserPermission || !hasPermission) && (jsx("span", { className: "str-video__no-media-permission", children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }) }) }));
};

const ToggleVideoPreviewButton = (props) => {
    const { caption, Menu = DeviceSelectorVideo, menuPlacement = 'top', onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
    const { t } = useI18n();
    const { useCameraState } = useCallStateHooks();
    const { camera, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute, } = useCameraState({ optimisticUpdates });
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, () => camera.toggle());
    return (jsx(WithTooltip, { title: !hasBrowserPermission
            ? t('Check your browser video permissions')
            : (caption ?? t('Video')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optionsAwareIsMute, caption: caption, className: clsx(!hasBrowserPermission && 'str-video__device-unavailable'), variant: "secondary", "data-testid": optionsAwareIsMute
                ? 'preview-video-unmute-button'
                : 'preview-video-mute-button', onClick: handleClick, disabled: !hasBrowserPermission || (!optimisticUpdates && isTogglePending), Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: [jsx(Icon, { icon: !optionsAwareIsMute ? 'camera' : 'camera-off' }), !hasBrowserPermission && (jsx("span", { className: "str-video__no-media-permission", title: t('Check your browser video permissions'), children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }));
};
const ToggleVideoPublishingButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = jsx(DeviceSelectorVideo, { visualType: "list" }), menuPlacement = 'top', onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_VIDEO);
    const { useCameraState, useCallSettings } = useCallStateHooks();
    const { camera, optionsAwareIsMute, hasBrowserPermission, isPromptingPermission, isTogglePending, } = useCameraState({ optimisticUpdates });
    const callSettings = useCallSettings();
    const isPublishingVideoAllowed = callSettings?.video.enabled;
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await camera.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: jsx(PermissionNotification, { permission: OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your video.'), messageAwaitingApproval: t('Awaiting for an approval to share your video.'), messageRevoked: t('You can no longer share your video.'), children: jsx(WithTooltip, { title: !hasPermission
                    ? t('You have no permission to share your video')
                    : !hasBrowserPermission
                        ? t('Check your browser video permissions')
                        : !isPublishingVideoAllowed
                            ? t('Video publishing is disabled by the system')
                            : caption || t('Video'), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optionsAwareIsMute, caption: caption, variant: "secondary", disabled: !hasBrowserPermission ||
                        !hasPermission ||
                        !isPublishingVideoAllowed ||
                        (!optimisticUpdates && isTogglePending), "data-testid": optionsAwareIsMute ? 'video-unmute-button' : 'video-mute-button', onClick: handleClick, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                        setTooltipDisabled(shown);
                        onMenuToggle?.(shown);
                    }, children: [jsx(Icon, { icon: optionsAwareIsMute ? 'camera-off' : 'camera' }), (!hasBrowserPermission ||
                            !hasPermission ||
                            !isPublishingVideoAllowed) && (jsx("span", { className: "str-video__no-media-permission", children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }) }) }));
};

const EndCallMenu = (props) => {
    const { onLeave, onEnd } = props;
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__end-call__confirmation", children: [jsxs("button", { className: "str-video__button str-video__end-call__leave", type: "button", "data-testid": "leave-call-button", onClick: onLeave, children: [jsx(Icon, { className: "str-video__button__icon str-video__end-call__leave-icon", icon: "logout" }), t('Leave call')] }), jsx(Restricted, { requiredGrants: [OwnCapability.END_CALL], children: jsxs("button", { className: "str-video__button str-video__end-call__end", type: "button", "data-testid": "end-call-for-all-button", onClick: onEnd, children: [jsx(Icon, { className: "str-video__button__icon str-video__end-call__end-icon", icon: "call-end" }), t('End call for all')] }) })] }));
};
const CancelCallToggleMenuButton = forwardRef(function CancelCallToggleMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(WithTooltip, { title: t('Leave call'), tooltipDisabled: menuShown, children: jsx(IconButton, { icon: menuShown ? 'close' : 'call-end', variant: menuShown ? 'active' : 'danger', "data-testid": "leave-call-button", ref: ref }) }));
});
const CancelCallConfirmButton = ({ onClick, onLeave, }) => {
    const call = useCall();
    const handleLeave = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.leave();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    const handleEndCall = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.endCall();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    return (jsx(MenuToggle, { placement: "top-start", ToggleButton: CancelCallToggleMenuButton, children: jsx(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) }));
};
const CancelCallButton = ({ disabled, caption, onClick, onLeave, }) => {
    const call = useCall();
    const { t } = useI18n();
    const handleClick = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.leave();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    return (jsx(IconButton, { disabled: disabled, icon: "call-end", variant: "danger", title: caption ?? t('Leave call'), "data-testid": "cancel-call-button", onClick: handleClick }));
};

const CallControls = ({ onLeave }) => (jsxs("div", { className: "str-video__call-controls", children: [jsx(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: jsx(MicCaptureErrorNotification, { children: jsx(SpeakingWhileMutedNotification, { children: jsx(ToggleAudioPublishingButton, {}) }) }) }), jsx(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: jsx(ToggleVideoPublishingButton, {}) }), jsx(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: jsx(ReactionsButton, {}) }), jsx(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: jsx(ScreenShareButton, {}) }), jsx(Restricted, { requiredGrants: [
                OwnCapability.START_RECORD_CALL,
                OwnCapability.STOP_RECORD_CALL,
            ], children: jsx(RecordCallButton, {}) }), jsx(CancelCallButton, { onLeave: onLeave })] }));

const CallStatsLatencyChart = lazy(() => import('./latency-chart-Bj5OSYzg.es.js'));
var Status;
(function (Status) {
    Status["GOOD"] = "Good";
    Status["OK"] = "Ok";
    Status["BAD"] = "Bad";
})(Status || (Status = {}));
const CallStats = (props) => {
    const { latencyLowBound = 75, latencyHighBound = 400, audioJitterLowBound = 10, audioJitterHighBound = 30, videoJitterLowBound = 20, videoJitterHighBound = 50, showCodecInfo = false, LatencyChartSuspenseFallback = null, } = props;
    const [latencyBuffer, setLatencyBuffer] = useState(() => {
        const now = Date.now();
        return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));
    });
    const { t } = useI18n();
    const [publishBitrate, setPublishBitrate] = useState('-');
    const [subscribeBitrate, setSubscribeBitrate] = useState('-');
    const [publishAudioBitrate, setPublishAudioBitrate] = useState('-');
    const [subscribeAudioBitrate, setSubscribeAudioBitrate] = useState('-');
    const previousStats = useRef(undefined);
    const { useCallStatsReport } = useCallStateHooks();
    const callStatsReport = useCallStatsReport();
    useEffect(() => {
        if (!callStatsReport)
            return;
        if (!previousStats.current) {
            previousStats.current = callStatsReport;
            return;
        }
        const previousCallStatsReport = previousStats.current;
        setPublishBitrate(() => {
            return calculatePublishBitrate(previousCallStatsReport, callStatsReport);
        });
        setSubscribeBitrate(() => {
            return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);
        });
        setPublishAudioBitrate(() => {
            return calculatePublishAudioBitrate(previousCallStatsReport, callStatsReport);
        });
        setSubscribeAudioBitrate(() => {
            return calculateSubscribeAudioBitrate(previousCallStatsReport, callStatsReport);
        });
        setLatencyBuffer((latencyBuf) => {
            const newLatencyBuffer = latencyBuf.slice(-19);
            newLatencyBuffer.push({
                x: callStatsReport.timestamp,
                y: callStatsReport.publisherStats.averageRoundTripTimeInMs ||
                    callStatsReport.publisherAudioStats.averageRoundTripTimeInMs,
            });
            return newLatencyBuffer;
        });
        previousStats.current = callStatsReport;
    }, [callStatsReport]);
    const latencyComparison = {
        lowBound: latencyLowBound,
        highBound: latencyHighBound,
        value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0,
    };
    const audioJitterComparison = {
        lowBound: audioJitterLowBound,
        highBound: audioJitterHighBound,
    };
    const videoJitterComparison = {
        lowBound: videoJitterLowBound,
        highBound: videoJitterHighBound,
    };
    return (jsx("div", { className: "str-video__call-stats", children: callStatsReport && (jsxs(Fragment, { children: [jsxs("div", { className: "str-video__call-stats__header", children: [jsxs("h3", { className: "str-video__call-stats__heading", children: [jsx(Icon, { className: "str-video__call-stats__icon", icon: "call-latency" }), t('Call Latency')] }), jsx("p", { className: "str-video__call-stats__description", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), jsx("div", { className: "str-video__call-stats__latencychart", children: jsx(Suspense, { fallback: LatencyChartSuspenseFallback, children: jsx(CallStatsLatencyChart, { values: latencyBuffer }) }) }), jsxs("div", { className: "str-video__call-stats__header", children: [jsxs("h3", { className: "str-video__call-stats__heading", children: [jsx(Icon, { className: "str-video__call-stats__icon", icon: "network-quality" }), t('Video performance')] }), jsx("p", { className: "str-video__call-stats__description", children: t('Review the key data points below to assess call performance') })] }), jsxs("div", { className: "str-video__call-stats__card-container", children: [jsx(StatCard, { label: t('Region'), value: callStatsReport.datacenter }), jsx(StatCard, { label: t('Latency'), value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), jsx(StatCard, { label: t('Receive jitter'), value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {
                                ...videoJitterComparison,
                                value: callStatsReport.subscriberStats.averageJitterInMs,
                            } }), jsx(StatCard, { label: t('Publish jitter'), value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {
                                ...videoJitterComparison,
                                value: callStatsReport.publisherStats.averageJitterInMs,
                            } }), jsx(StatCard, { label: `${t('Publish resolution')}${showCodecInfo ? formatCodec(callStatsReport) : ''}`, value: toFrameSize(callStatsReport.publisherStats) }), jsx(StatCard, { label: t('Publish quality drop reason'), value: callStatsReport.publisherStats.qualityLimitationReasons }), jsx(StatCard, { label: t('Receiving resolution'), value: toFrameSize(callStatsReport.subscriberStats) }), jsx(StatCard, { label: t('Receive quality drop reason'), value: callStatsReport.subscriberStats.qualityLimitationReasons }), jsx(StatCard, { label: t('Publish bitrate'), value: publishBitrate }), jsx(StatCard, { label: t('Receiving bitrate'), value: subscribeBitrate })] }), jsxs("div", { className: "str-video__call-stats__header", children: [jsxs("h3", { className: "str-video__call-stats__heading", children: [jsx(Icon, { className: "str-video__call-stats__icon", icon: "mic" }), t('Audio Performance')] }), jsx("p", { className: "str-video__call-stats__description", children: t('Review the key audio data points below to assess audio performance') })] }), jsxs("div", { className: "str-video__call-stats__card-container", children: [jsx(StatCard, { label: t('Latency'), value: `${callStatsReport.publisherAudioStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), jsx(StatCard, { label: t('Audio codec'), value: formatAudioCodec(callStatsReport) }), jsx(StatCard, { label: t('Audio bitrate (publish)'), value: publishAudioBitrate }), jsx(StatCard, { label: t('Audio bitrate (receive)'), value: subscribeAudioBitrate }), jsx(StatCard, { label: t('Audio jitter (publish)'), value: `${callStatsReport.publisherAudioStats.averageJitterInMs} ms.`, comparison: {
                                ...audioJitterComparison,
                                value: callStatsReport.publisherAudioStats.averageJitterInMs,
                            } }), jsx(StatCard, { label: t('Audio jitter (receive)'), value: `${callStatsReport.subscriberAudioStats.averageJitterInMs} ms.`, comparison: {
                                ...audioJitterComparison,
                                value: callStatsReport.subscriberAudioStats.averageJitterInMs,
                            } })] })] })) }));
};
const StatCardExplanation = (props) => {
    const { description } = props;
    const [isOpen, setIsOpen] = useState(false);
    const { refs, floatingStyles, context } = useFloating({
        open: isOpen,
        onOpenChange: setIsOpen,
    });
    const hover = useHover(context);
    const { getReferenceProps, getFloatingProps } = useInteractions([hover]);
    return (jsxs(Fragment, { children: [jsx("div", { className: "str-video__call-explanation", ref: refs.setReference, ...getReferenceProps(), children: jsx(Icon, { className: "str-video__call-explanation__icon", icon: "info" }) }), isOpen && (jsx("div", { className: "str-video__call-explanation__description", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description }))] }));
};
const StatsTag = (props) => {
    const { children, status } = props;
    return (jsx("div", { className: clsx('str-video__call-stats__tag', {
            'str-video__call-stats__tag--good': status === Status.GOOD,
            'str-video__call-stats__tag--ok': status === Status.OK,
            'str-video__call-stats__tag--bad': status === Status.BAD,
        }), children: jsx("div", { className: "str-video__call-stats__tag__text", children: children }) }));
};
const StatCard = (props) => {
    const { label, value, description, comparison } = props;
    const { t } = useI18n();
    const status = comparison ? toStatus(comparison) : undefined;
    return (jsxs("div", { className: "str-video__call-stats__card", children: [jsxs("div", { className: "str-video__call-stats__card-content", children: [jsxs("div", { className: "str-video__call-stats__card-label", children: [label, description && jsx(StatCardExplanation, { description: description })] }), jsx("div", { className: "str-video__call-stats__card-value", children: value })] }), status && jsx(StatsTag, { status: status, children: t(status) })] }));
};
const toStatus = (config) => {
    const { value, lowBound, highBound } = config;
    if (value <= lowBound)
        return Status.GOOD;
    if (value >= lowBound && value <= highBound)
        return Status.OK;
    if (value >= highBound)
        return Status.BAD;
    return Status.GOOD;
};
const toFrameSize = (stats) => {
    const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps, } = stats;
    let size = `-`;
    if (w && h) {
        size = `${w}x${h}`;
        if (fps) {
            size += `@${fps}fps.`;
        }
    }
    return size;
};
const formatCodec = (callStatsReport) => {
    const { codecPerTrackType } = callStatsReport.publisherStats;
    if (!codecPerTrackType || !codecPerTrackType[SfuModels.TrackType.VIDEO]) {
        return '';
    }
    const [, name] = codecPerTrackType[SfuModels.TrackType.VIDEO].split('/');
    return name ? ` (${name})` : '';
};
const formatAudioCodec = (callStatsReport) => {
    const { codecPerTrackType } = callStatsReport.publisherAudioStats;
    if (!codecPerTrackType || !codecPerTrackType[SfuModels.TrackType.AUDIO]) {
        return '';
    }
    const [, name] = codecPerTrackType[SfuModels.TrackType.AUDIO].split('/');
    return name ?? '';
};
const calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {
    const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp, }, } = previousCallStatsReport;
    const { publisherStats: { totalBytesSent, timestamp }, } = callStatsReport;
    const bytesSent = totalBytesSent - previousTotalBytesSent;
    const timeElapsed = timestamp - previousTimestamp;
    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;
};
const calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {
    const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp, }, } = previousCallStatsReport;
    const { subscriberStats: { totalBytesReceived, timestamp }, } = callStatsReport;
    const bytesReceived = totalBytesReceived - previousTotalBytesReceived;
    const timeElapsed = timestamp - previousTimestamp;
    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;
};
const calculatePublishAudioBitrate = (previousCallStatsReport, callStatsReport) => {
    const previousAudioStats = previousCallStatsReport.publisherAudioStats;
    const audioStats = callStatsReport.publisherAudioStats;
    const bytesSent = audioStats.totalBytesSent - previousAudioStats.totalBytesSent;
    const timeElapsed = audioStats.timestamp - previousAudioStats.timestamp;
    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;
};
const calculateSubscribeAudioBitrate = (previousCallStatsReport, callStatsReport) => {
    const previousAudioStats = previousCallStatsReport.subscriberAudioStats;
    const audioStats = callStatsReport.subscriberAudioStats;
    const bytesReceived = audioStats.totalBytesReceived - previousAudioStats.totalBytesReceived;
    const timeElapsed = audioStats.timestamp - previousAudioStats.timestamp;
    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;
};

const CallStatsButton = () => (jsx(MenuToggle, { placement: "top-end", ToggleButton: ToggleMenuButton, children: jsx(CallStats, {}) }));
const ToggleMenuButton = forwardRef(function ToggleMenuButton(props, ref) {
    const { t } = useI18n();
    const { caption, menuShown } = props;
    return (jsx(CompositeButton, { ref: ref, active: menuShown, caption: caption, title: caption || t('Statistics'), "data-testid": "stats-button", children: jsx(Icon, { icon: "stats" }) }));
});

const ToggleAudioOutputButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = DeviceSelectorAudioOutput, menuPlacement = 'top', onMenuToggle, } = props;
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    return (jsx(WithTooltip, { title: caption || t('Speakers'), tooltipDisabled: tooltipDisabled, children: jsx(CompositeButton, { Menu: Menu, menuPlacement: menuPlacement, caption: caption, "data-testid": "audio-output-button", onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: jsx(Icon, { icon: "speaker" }) }) }));
};

const BlockedUserListing = ({ data }) => {
    if (!data.length)
        return null;
    return (jsx(Fragment, { children: jsx("div", { className: "str-video__participant-listing", children: data.map((userId) => (jsx(BlockedUserListingItem, { userId: userId }, userId))) }) }));
};
const BlockedUserListingItem = ({ userId }) => {
    const call = useCall();
    const unblockUserClickHandler = () => {
        if (userId)
            call?.unblockUser(userId);
    };
    return (jsxs("div", { className: "str-video__participant-listing-item", children: [jsx("div", { className: "str-video__participant-listing-item__display-name", children: userId }), jsx(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: jsx(TextButton, { onClick: unblockUserClickHandler, children: "Unblock" }) })] }));
};

const CallParticipantListHeader = ({ onClose, }) => {
    const { useParticipants, useAnonymousParticipantCount } = useCallStateHooks();
    const participants = useParticipants();
    const anonymousParticipantCount = useAnonymousParticipantCount();
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__participant-list-header", children: [jsxs("div", { className: "str-video__participant-list-header__title", children: [t('Participants'), ' ', jsxs("span", { className: "str-video__participant-list-header__title-count", children: ["[", participants.length, "]"] }), anonymousParticipantCount > 0 && (jsx("span", { className: "str-video__participant-list-header__title-anonymous", children: t('Anonymous', { count: anonymousParticipantCount }) }))] }), jsx(IconButton, { onClick: onClose, className: "str-video__participant-list-header__close-button", icon: "close" })] }));
};

const CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName, }) => {
    const isAudioOn = hasAudio(participant);
    const isVideoOn = hasVideo(participant);
    const isPinnedOn = isPinned(participant);
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__participant-listing-item", children: [jsx(Avatar, { name: participant.name, imageSrc: participant.image }), jsx(DisplayName, { participant: participant }), jsxs("div", { className: "str-video__participant-listing-item__media-indicator-group", children: [jsx(MediaIndicator, { title: isAudioOn ? t('Microphone on') : t('Microphone off'), className: clsx('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isAudioOn ? 'mic' : 'mic-off'}`) }), jsx(MediaIndicator, { title: isVideoOn ? t('Camera on') : t('Camera off'), className: clsx('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isVideoOn ? 'camera' : 'camera-off'}`) }), isPinnedOn && (jsx(MediaIndicator, { title: t('Pinned'), className: clsx('str-video__participant-listing-item__icon', 'str-video__participant-listing-item__icon-pinned') })), jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$2, children: jsx(ParticipantViewContext.Provider, { value: { participant, trackType: 'none' }, children: jsx(ParticipantActionsContextMenu, {}) }) })] })] }));
};
const MediaIndicator = (props) => (jsx(WithTooltip, { ...props }));
const DefaultDisplayName = ({ participant }) => {
    const connectedUser = useConnectedUser();
    const { t } = useI18n();
    const meFlag = participant.userId === connectedUser?.id ? t('Me') : '';
    const nameOrId = participant.name || participant.userId || t('Unknown');
    let displayName;
    if (!participant.name) {
        displayName = meFlag || nameOrId || t('Unknown');
    }
    else if (meFlag) {
        displayName = `${nameOrId} (${meFlag})`;
    }
    else {
        displayName = nameOrId;
    }
    return (jsx(WithTooltip, { className: "str-video__participant-listing-item__display-name", title: displayName, children: displayName }));
};
const ToggleButton$2 = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref: ref });
});

const CallParticipantListing = ({ data, }) => (jsx("div", { className: "str-video__participant-listing", children: data.map((participant) => (jsx(CallParticipantListingItem, { participant: participant }, participant.sessionId))) }));

const EmptyParticipantSearchList = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__participant-list--empty", children: t('No participants found') }));
};

const SearchInput = ({ exitSearch, isActive, ...rest }) => {
    const [inputElement, setInputElement] = useState(null);
    useEffect(() => {
        if (!inputElement)
            return;
        const handleKeyDown = (e) => {
            if (e.key.toLowerCase() === 'escape')
                exitSearch();
        };
        inputElement.addEventListener('keydown', handleKeyDown);
        return () => {
            inputElement.removeEventListener('keydown', handleKeyDown);
        };
    }, [exitSearch, inputElement]);
    return (jsxs("div", { className: clsx('str-video__search-input__container', {
            'str-video__search-input__container--active': isActive,
        }), children: [jsx("input", { placeholder: "Search", ...rest, ref: setInputElement }), isActive ? (jsx("button", { className: "str-video__search-input__clear-btn", onClick: exitSearch, children: jsx("span", { className: "str-video__search-input__icon--active" }) })) : (jsx("span", { className: "str-video__search-input__icon" }))] }));
};

function SearchResults({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList, }) {
    if (searchQueryInProgress) {
        return (jsx("div", { className: "str-video__search-results--loading", children: jsx(LoadingIndicator$1, {}) }));
    }
    if (!searchResults.length) {
        return jsx(EmptySearchResultComponent, {});
    }
    return jsx(SearchResultList, { data: searchResults });
}

const useSearch = ({ debounceInterval = 200, searchFn, searchQuery = '', }) => {
    const [searchResults, setSearchResults] = useState([]);
    const [searchQueryInProgress, setSearchQueryInProgress] = useState(false);
    const searchFnRef = useRef(searchFn);
    searchFnRef.current = searchFn;
    useEffect(() => {
        if (!searchQuery.length) {
            setSearchQueryInProgress(false);
            setSearchResults([]);
            return;
        }
        setSearchQueryInProgress(true);
        const timeout = setTimeout(async () => {
            try {
                const results = await searchFnRef.current(searchQuery);
                setSearchResults(results);
            }
            catch (error) {
                console.error(error);
            }
            finally {
                setSearchQueryInProgress(false);
            }
        }, debounceInterval);
        return () => {
            clearTimeout(timeout);
        };
    }, [debounceInterval, searchQuery]);
    return {
        searchQueryInProgress,
        searchResults,
    };
};

const UserListTypes = {
    active: 'Active users',
    blocked: 'Blocked users',
};
const CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval, }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [userListType, setUserListType] = useState('active');
    const exitSearch = useCallback(() => setSearchQuery(''), []);
    return (jsxs("div", { className: "str-video__participant-list", children: [jsx(CallParticipantListHeader, { onClose: onClose }), jsx(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch: exitSearch, isActive: !!searchQuery }), jsx(CallParticipantListContentHeader, { userListType: userListType, setUserListType: setUserListType }), jsxs("div", { className: "str-video__participant-list__content", children: [userListType === 'active' && (jsx(ActiveUsersSearchResults, { searchQuery: searchQuery, activeUsersSearchFn: activeUsersSearchFn, debounceSearchInterval: debounceSearchInterval })), userListType === 'blocked' && (jsx(BlockedUsersSearchResults, { searchQuery: searchQuery, blockedUsersSearchFn: blockedUsersSearchFn, debounceSearchInterval: debounceSearchInterval }))] })] }));
};
const CallParticipantListContentHeader = ({ userListType, setUserListType, }) => {
    const call = useCall();
    const { t } = useI18n();
    const muteAll = useCallback(() => {
        call?.muteAllUsers('audio');
    }, [call]);
    return (jsxs("div", { className: "str-video__participant-list__content-header", children: [jsx("div", { className: "str-video__participant-list__content-header-title", children: userListType === 'active' && (jsx(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: jsx(TextButton, { onClick: muteAll, children: t('Mute all') }) })) }), jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$1, children: jsx(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => (jsx(GenericMenuButtonItem, { "aria-selected": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt))) }) })] }));
};
const ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval, }) => {
    const { useParticipants } = useCallStateHooks();
    const participants = useParticipants({ sortBy: name });
    const activeUsersSearchFn = useCallback(async (queryString) => {
        const normalizedQuery = normalizeString(queryString);
        const queryRegExp = new RegExp(normalizedQuery, 'i');
        return participants.filter((p) => normalizeString(p.name).match(queryRegExp));
    }, [participants]);
    const { searchQueryInProgress, searchResults } = useSearch({
        searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,
        debounceInterval: debounceSearchInterval,
        searchQuery,
    });
    return (jsx(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing }));
};
const BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval, searchQuery, }) => {
    const { useCallBlockedUserIds } = useCallStateHooks();
    const blockedUsers = useCallBlockedUserIds();
    const blockedUsersSearchFn = useCallback(async (queryString) => {
        const queryRegExp = new RegExp(queryString, 'i');
        return blockedUsers.filter((userId) => userId.match(queryRegExp));
    }, [blockedUsers]);
    const { searchQueryInProgress, searchResults } = useSearch({
        searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,
        debounceInterval: debounceSearchInterval,
        searchQuery,
    });
    return (jsx(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing }));
};
const ToggleButton$1 = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "filter", ref: ref });
});

const CallPreview = (props) => {
    const { className, style } = props;
    const call = useCall();
    const { useCallThumbnail } = useCallStateHooks();
    const thumbnail = useCallThumbnail();
    const [imageRef, setImageRef] = useState(null);
    useEffect(() => {
        if (!imageRef || !call)
            return;
        const cleanup = call.bindCallThumbnailElement(imageRef);
        return () => cleanup();
    }, [imageRef, call]);
    if (!thumbnail)
        return null;
    return (jsx("img", { className: clsx('str-video__call-preview', className), style: style, alt: "Call Preview Thumbnail", ref: setImageRef }));
};

const CallRecordingListHeader = ({ callRecordings, onRefresh, }) => {
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__call-recording-list__header", children: [jsxs("div", { className: "str-video__call-recording-list__title", children: [jsx("span", { children: t('Call Recordings') }), callRecordings.length ? jsxs("span", { children: ["(", callRecordings.length, ")"] }) : null] }), onRefresh && (jsx(IconButton, { icon: "refresh", title: t('Refresh'), onClick: onRefresh }))] }));
};

const dateFormat = (date) => {
    const format = new Date(date);
    return format.toTimeString().split(' ')[0];
};
const CallRecordingListItem = ({ recording, }) => {
    return (jsxs("li", { className: "str-video__call-recording-list__item", children: [jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__filename", children: recording.filename }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.start_time) }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.end_time) }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__download", children: jsx("a", { className: clsx('str-video__call-recording-list-item__action-button', 'str-video__call-recording-list-item__action-button--download'), role: "button", href: recording.url, download: recording.filename, title: "Download the recording", children: jsx(Icon, { icon: "download" }) }) })] }));
};

const EmptyCallRecordingListing = () => {
    return (jsxs("div", { className: "str-video__call-recording-list__listing str-video__call-recording-list__listing--empty", children: [jsx("div", { className: "str-video__call-recording-list__listing--icon-empty" }), jsx("p", { className: "str-video__call-recording-list__listing--text-empty", children: "No recordings available" })] }));
};

const LoadingCallRecordingListing = ({ callRecordings, }) => {
    return (jsxs(Fragment, { children: [callRecordings.map((recording) => (jsx(CallRecordingListItem, { recording: recording }, recording.filename))), jsx(LoadingIndicator, { text: "Recording getting ready" })] }));
};

const CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh, }) => {
    return (jsxs("div", { className: "str-video__call-recording-list", children: [jsx(CallRecordingListHeader$1, { callRecordings: callRecordings, onRefresh: onRefresh }), jsx("div", { className: "str-video__call-recording-list__listing", children: loading ? (jsx(LoadingCallRecordingList, { callRecordings: callRecordings })) : callRecordings.length ? (jsxs(Fragment, { children: [jsx("ul", { className: "str-video__call-recording-list__list", children: jsxs("li", { className: "str-video__call-recording-list__item", children: [jsx("div", { className: "str-video__call-recording-list__filename", children: "Name" }), jsx("div", { className: "str-video__call-recording-list__time", children: "Start time" }), jsx("div", { className: "str-video__call-recording-list__time", children: "End time" }), jsx("div", { className: "str-video__call-recording-list__download" })] }) }), jsx("ul", { className: "str-video__call-recording-list__list", children: callRecordings.map((recording) => (jsx(CallRecordingListItem$1, { recording: recording }, recording.filename))) })] })) : (jsx(EmptyCallRecordingList, {})) })] }));
};

const NoiseCancellationContext = createContext(null);
/**
 * Exposes the NoiseCancellation API.
 * Throws an error if used outside <NoiseCancellationProvider />.
 */
const useNoiseCancellation = () => {
    const context = useContext(NoiseCancellationContext);
    if (!context) {
        throw new Error('useNoiseCancellation must be used within a NoiseCancellationProvider');
    }
    return context;
};
const NoiseCancellationProvider = (props) => {
    const { children, noiseCancellation } = props;
    const call = useCall();
    const { useCallSettings, useHasPermissions } = useCallStateHooks();
    const settings = useCallSettings();
    const noiseCancellationAllowed = !!(settings &&
        settings.audio.noise_cancellation &&
        settings.audio.noise_cancellation.mode !==
            NoiseCancellationSettingsModeEnum.DISABLED);
    const hasCapability = useHasPermissions(OwnCapability.ENABLE_NOISE_CANCELLATION);
    const [isSupportedByBrowser, setIsSupportedByBrowser] = useState();
    useEffect(() => {
        const result = noiseCancellation.isSupported();
        if (typeof result === 'boolean') {
            setIsSupportedByBrowser(result);
        }
        else {
            result
                .then((s) => setIsSupportedByBrowser(s))
                .catch((err) => console.error(`Can't determine if noise cancellation is supported`, err));
        }
    }, [noiseCancellation]);
    const isSupported = isSupportedByBrowser && hasCapability && noiseCancellationAllowed;
    const [isEnabled, setIsEnabled] = useState(false);
    const deinit = useRef(undefined);
    useEffect(() => {
        if (!call || !isSupported)
            return;
        noiseCancellation.isEnabled().then((e) => setIsEnabled(e));
        const unsubscribe = noiseCancellation.on('change', (v) => setIsEnabled(v));
        const init = (deinit.current || Promise.resolve())
            .then(() => noiseCancellation.init({ tracer: call.tracer }))
            .then(() => call.microphone.enableNoiseCancellation(noiseCancellation))
            .catch((e) => console.error(`Can't initialize noise cancellation`, e));
        return () => {
            deinit.current = init
                .then(() => call.microphone.disableNoiseCancellation())
                .then(() => noiseCancellation.dispose())
                .then(() => unsubscribe());
        };
    }, [call, isSupported, noiseCancellation]);
    const contextValue = useMemo(() => ({
        isSupported,
        isEnabled,
        setSuppressionLevel: (level) => {
            if (!noiseCancellation)
                return;
            noiseCancellation.setSuppressionLevel(level);
        },
        setEnabled: (enabledOrSetter) => {
            if (!noiseCancellation)
                return;
            const enable = typeof enabledOrSetter === 'function'
                ? enabledOrSetter(isEnabled)
                : enabledOrSetter;
            if (enable) {
                noiseCancellation.enable().catch((err) => {
                    console.error('Failed to enable noise cancellation', err);
                });
            }
            else {
                noiseCancellation.disable().catch((err) => {
                    console.error('Failed to disable noise cancellation', err);
                });
            }
        },
    }), [isEnabled, isSupported, noiseCancellation]);
    return (jsx(NoiseCancellationContext.Provider, { value: contextValue, children: children }));
};

const RingingCallControls = () => {
    const call = useCall();
    const { useCallCallingState } = useCallStateHooks();
    const callCallingState = useCallCallingState();
    if (!call)
        return null;
    const buttonsDisabled = callCallingState !== CallingState.RINGING;
    return (jsx("div", { className: "str-video__pending-call-controls", children: call.isCreatedByMe ? (jsx(CancelCallButton, { disabled: buttonsDisabled })) : (jsxs(Fragment, { children: [jsx(AcceptCallButton, { disabled: buttonsDisabled }), jsx(CancelCallButton, { onClick: () => {
                        const reason = call.isCreatedByMe ? 'cancel' : 'decline';
                        call.leave({ reject: true, reason });
                    }, disabled: buttonsDisabled })] })) }));
};

const CALLING_STATE_TO_LABEL = {
    [CallingState.JOINING]: 'Joining',
    [CallingState.RINGING]: 'Ringing',
    [CallingState.MIGRATING]: 'Migrating',
    [CallingState.RECONNECTING]: 'Re-connecting',
    [CallingState.RECONNECTING_FAILED]: 'Failed',
    [CallingState.OFFLINE]: 'No internet connection',
    [CallingState.IDLE]: '',
    [CallingState.UNKNOWN]: '',
    [CallingState.JOINED]: 'Joined',
    [CallingState.LEFT]: 'Left call',
};
const RingingCall = (props) => {
    const { includeSelf = false, totalMembersToShow = 3 } = props;
    const call = useCall();
    const { t } = useI18n();
    const { useCallCallingState, useCallMembers } = useCallStateHooks();
    const callingState = useCallCallingState();
    const members = useCallMembers();
    const connectedUser = useConnectedUser();
    if (!call)
        return null;
    // take the first N members to show their avatars
    const membersToShow = (members || [])
        .slice(0, totalMembersToShow)
        .map(({ user }) => user)
        .filter((user) => user.id !== connectedUser?.id || includeSelf);
    if (includeSelf &&
        !membersToShow.find((user) => user.id === connectedUser?.id)) {
        // if the current user is not in the initial batch of members,
        // replace the first item in membersToShow array with the current user
        const self = members.find(({ user }) => user.id === connectedUser?.id);
        if (self) {
            membersToShow.splice(0, 1, self.user);
        }
    }
    const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];
    return (jsxs("div", { className: "str-video__call-panel str-video__call-panel--ringing", children: [jsx("div", { className: "str-video__call-panel__members-list", children: membersToShow.map((user) => (jsxs("div", { className: "str-video__call-panel__member-box", children: [jsx(Avatar, { name: user.name, imageSrc: user.image }), user.name && (jsx("div", { className: "str-video__member_details", children: jsx("span", { className: "str-video__member_name", children: user.name }) }))] }, user.id))) }), callingStateLabel && (jsx("div", { className: "str-video__call-panel__calling-state-label", children: t(callingStateLabel) })), [CallingState.RINGING, CallingState.JOINING].includes(callingState) && (jsx(RingingCallControls, {}))] }));
};

const byNameOrId = (a, b) => {
    if (a.name && b.name && a.name < b.name)
        return -1;
    if (a.name && b.name && a.name > b.name)
        return 1;
    if (a.id < b.id)
        return -1;
    if (a.id > b.id)
        return 1;
    return 0;
};
const PermissionRequests = () => {
    const call = useCall();
    const { useLocalParticipant, useHasPermissions } = useCallStateHooks();
    const localParticipant = useLocalParticipant();
    const [expanded, setExpanded] = useState(false);
    const [permissionRequests, setPermissionRequests] = useState([]);
    const canUpdateCallPermissions = useHasPermissions(OwnCapability.UPDATE_CALL_PERMISSIONS);
    const localUserId = localParticipant?.userId;
    useEffect(() => {
        if (!call || !canUpdateCallPermissions)
            return;
        return call.on('call.permission_request', (event) => {
            if (event.user.id !== localUserId) {
                setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));
            }
        });
    }, [call, canUpdateCallPermissions, localUserId]);
    const handleUpdatePermission = (request, type) => {
        return async () => {
            const { user, permissions } = request;
            switch (type) {
                case 'grant':
                    await call?.grantPermissions(user.id, permissions);
                    break;
                case 'revoke':
                    await call?.revokePermissions(user.id, permissions);
                    break;
            }
            setPermissionRequests((requests) => requests.filter((r) => r !== request));
        };
    };
    const { refs, x, y, strategy } = useFloatingUIPreset({
        placement: 'bottom',
        strategy: 'absolute',
    });
    // don't render anything if there are no permission requests
    if (permissionRequests.length === 0)
        return null;
    return (jsxs("div", { className: "str-video__permission-requests", ref: refs.setReference, children: [jsxs("div", { className: "str-video__permission-requests__notification", children: [jsxs("span", { className: "str-video__permission-requests__notification__message", children: [permissionRequests.length, " pending permission requests"] }), jsx(Button, { type: "button", onClick: () => {
                            setExpanded((e) => !e);
                        }, children: expanded ? 'Hide requests' : 'Show requests' })] }), expanded && (jsx(PermissionRequestList, { ref: refs.setFloating, style: {
                    position: strategy,
                    top: y ?? 0,
                    left: x ?? 0,
                    overflowY: 'auto',
                }, permissionRequests: permissionRequests, handleUpdatePermission: handleUpdatePermission }))] }));
};
const PermissionRequestList = forwardRef(function PermissionRequestList(props, ref) {
    const { permissionRequests, handleUpdatePermission, ...rest } = props;
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__permission-requests-list", ref: ref, ...rest, children: permissionRequests.map((request, reqIndex) => {
            const { user, permissions } = request;
            return (jsx(Fragment$1, { children: permissions.map((permission) => (jsxs("div", { className: "str-video__permission-request", children: [jsx("div", { className: "str-video__permission-request__message", children: messageForPermission(user.name || user.id, permission, t) }), jsx(Button, { className: "str-video__permission-request__button--allow", type: "button", onClick: handleUpdatePermission(request, 'grant'), children: t('Allow') }), jsx(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, 'revoke'), children: t('Revoke') }), jsx(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, 'dismiss'), children: t('Dismiss') })] }, permission))) }, `${user.id}/${reqIndex}`));
        }) }));
});
const Button = (props) => {
    const { className, ...rest } = props;
    return (jsx("button", { className: clsx('str-video__permission-request__button', className), ...rest }));
};
const messageForPermission = (userName, permission, t) => {
    switch (permission) {
        case OwnCapability.SEND_AUDIO:
            return t('{{ userName }} is requesting to speak', { userName });
        case OwnCapability.SEND_VIDEO:
            return t('{{ userName }} is requesting to share their camera', {
                userName,
            });
        case OwnCapability.SCREENSHARE:
            return t('{{ userName }} is requesting to present their screen', {
                userName,
            });
        default:
            return t('{{ userName }} is requesting permission: {{ permission }}', {
                userName,
                permission,
            });
    }
};

const StreamTheme = ({ as: Component = 'div', className, children, ...props }) => {
    return (jsx(Component, { ...props, className: clsx('str-video', className), children: children }));
};

const DefaultDisabledVideoPreview = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str_video__video-preview__disabled-video-preview", children: t('Video is disabled') }));
};
const DefaultNoCameraPreview = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str_video__video-preview__no-camera-preview", children: t('No camera found') }));
};
const VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator, }) => {
    const { useCameraState } = useCallStateHooks();
    const { devices, status, isMute, mediaStream } = useCameraState();
    let contents;
    if (isMute && devices?.length === 0) {
        contents = jsx(NoCameraPreview, {});
    }
    else if (status === 'enabled') {
        const loading = !mediaStream;
        contents = (jsxs(Fragment, { children: [mediaStream && (jsx(BaseVideo, { stream: mediaStream, className: clsx('str-video__video-preview', {
                        'str-video__video-preview--mirror': mirror,
                        'str-video__video-preview--loading': loading,
                    }) })), loading && jsx(StartingCameraPreview, {})] }));
    }
    else {
        contents = jsx(DisabledVideoPreview, {});
    }
    return (jsx("div", { className: clsx('str-video__video-preview-container', className), children: contents }));
};

const ToggleButton = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref: ref });
});
const DefaultScreenShareOverlay = () => {
    const call = useCall();
    const { t } = useI18n();
    const stopScreenShare = () => {
        call?.screenShare.disable().catch((err) => {
            console.error('Failed to stop screen sharing:', err);
        });
    };
    return (jsxs("div", { className: "str-video__screen-share-overlay", children: [jsx(Icon, { icon: "screen-share-off" }), jsx("span", { className: "str-video__screen-share-overlay__title", children: t('You are presenting your screen') }), jsxs("button", { onClick: stopScreenShare, type: "button", className: "str-video__screen-share-overlay__button", children: [jsx(Icon, { icon: "close" }), " ", t('Stop Screen Sharing')] })] }));
};
const DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = 'bottom-start', showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu, }) => {
    const { participant, trackType } = useParticipantViewContext();
    const isScreenSharing = hasScreenShare(participant);
    if (participant.isLocalParticipant &&
        isScreenSharing &&
        trackType === 'screenShareTrack') {
        return (jsxs(Fragment, { children: [jsx(DefaultScreenShareOverlay, {}), jsx(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));
    }
    return (jsxs(Fragment, { children: [showMenuButton && (jsx(MenuToggle, { strategy: "fixed", placement: menuPlacement, ToggleButton: ToggleButton, children: jsx(ParticipantActionsContextMenu$1, {}) })), jsx(Reaction, { participant: participant }), jsx(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));
};
const ParticipantDetails = ({ indicatorsVisible = true, }) => {
    const { participant, trackType } = useParticipantViewContext();
    const { isLocalParticipant, connectionQuality, pin, sessionId, name, userId, } = participant;
    const call = useCall();
    const { t } = useI18n();
    const connectionQualityAsString = !!connectionQuality &&
        SfuModels.ConnectionQuality[connectionQuality].toLowerCase();
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const canUnpin = !!pin && pin.isLocalPin;
    const isTrackPaused = trackType !== 'none' ? hasPausedTrack(participant, trackType) : false;
    return (jsxs(Fragment, { children: [jsx("div", { className: "str-video__participant-details", children: jsxs("span", { className: "str-video__participant-details__name", children: [name || userId, indicatorsVisible && !hasAudioTrack && (jsx("span", { className: "str-video__participant-details__name--audio-muted" })), indicatorsVisible && !hasVideoTrack && (jsx("span", { className: "str-video__participant-details__name--video-muted" })), indicatorsVisible && isTrackPaused && (jsx("span", { title: t('Video paused due to insufficient bandwidth'), className: "str-video__participant-details__name--track-paused" })), indicatorsVisible && canUnpin && (
                        // TODO: remove this monstrosity once we have a proper design
                        jsx("span", { title: t('Unpin'), onClick: () => call?.unpin(sessionId), className: "str-video__participant-details__name--pinned" })), indicatorsVisible && jsx(SpeechIndicator, {})] }) }), indicatorsVisible && (jsx(Notification, { isVisible: isLocalParticipant &&
                    connectionQuality === SfuModels.ConnectionQuality.POOR, message: t('Poor connection quality'), children: connectionQualityAsString && (jsx("span", { className: clsx('str-video__participant-details__connection-quality', `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString })) }))] }));
};
const SpeechIndicator = () => {
    const { participant } = useParticipantViewContext();
    const { isSpeaking, isDominantSpeaker } = participant;
    return (jsxs("span", { className: clsx('str-video__speech-indicator', isSpeaking && 'str-video__speech-indicator--speaking', isDominantSpeaker && 'str-video__speech-indicator--dominant'), children: [jsx("span", { className: "str-video__speech-indicator__bar" }), jsx("span", { className: "str-video__speech-indicator__bar" }), jsx("span", { className: "str-video__speech-indicator__bar" })] }));
};

const ParticipantView = forwardRef(function ParticipantView({ participant, trackType = 'videoTrack', mirror, muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }, ref) {
    const { isLocalParticipant, isSpeaking, isDominantSpeaker, sessionId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const [trackedElement, setTrackedElement] = useState(null);
    const [contextVideoElement, setContextVideoElement] = useState(null);
    const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = useState(null);
    // TODO: allow to pass custom ViewportTracker instance from props
    useTrackElementVisibility({
        sessionId,
        trackedElement,
        trackType,
    });
    const { useIncomingVideoSettings } = useCallStateHooks();
    const { isParticipantVideoEnabled } = useIncomingVideoSettings();
    const participantViewContextValue = useMemo(() => ({
        participant,
        participantViewElement: trackedElement,
        videoElement: contextVideoElement,
        videoPlaceholderElement: contextVideoPlaceholderElement,
        trackType,
    }), [
        contextVideoElement,
        contextVideoPlaceholderElement,
        participant,
        trackedElement,
        trackType,
    ]);
    const videoRefs = useMemo(() => ({
        setVideoElement: (element) => {
            setVideoElement?.(element);
            setContextVideoElement(element);
        },
        setVideoPlaceholderElement: (element) => {
            setVideoPlaceholderElement?.(element);
            setContextVideoPlaceholderElement(element);
        },
    }), [setVideoElement, setVideoPlaceholderElement]);
    return (jsx("div", { "data-testid": "participant-view", ref: (element) => {
            applyElementToRef(ref, element);
            setTrackedElement(element);
        }, className: clsx('str-video__participant-view', isDominantSpeaker && 'str-video__participant-view--dominant-speaker', isSpeaking && 'str-video__participant-view--speaking', !hasVideoTrack && 'str-video__participant-view--no-video', !hasAudioTrack && 'str-video__participant-view--no-audio', className), children: jsxs(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && (jsxs(Fragment, { children: [hasAudioTrack && (jsx(Audio, { participant: participant, trackType: "audioTrack" })), hasScreenShareAudioTrack && (jsx(Audio, { participant: participant, trackType: "screenShareAudioTrack" }))] })), jsx(Video$1, { VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, participant: participant, trackType: trackType, refs: videoRefs, enabled: isLocalParticipant ||
                        trackType !== 'videoTrack' ||
                        isParticipantVideoEnabled(participant.sessionId), mirror: mirror, autoPlay: true }), isComponentType(ParticipantViewUI) ? (jsx(ParticipantViewUI, {})) : (ParticipantViewUI)] }) }));
});
ParticipantView.displayName = 'ParticipantView';

// re-exporting the StreamCallProvider as StreamCall
const StreamCall = StreamCallProvider;
StreamCall.displayName = 'StreamCall';

var Joining = "Joining";
var Mic = "Mic";
var Ringing = "Ringing";
var Speakers = "Speakers";
var Video = "Video";
var Live = "Live";
var Reactions = "Reactions";
var Statistics = "Statistics";
var Invite = "Invite";
var Join = "Join";
var You = "You";
var Me = "Me";
var Unknown = "Unknown";
var Default = "Default";
var Refresh = "Refresh";
var Allow = "Allow";
var Revoke = "Revoke";
var Dismiss = "Dismiss";
var Pinned = "Pinned";
var Unpin = "Unpin";
var Pin = "Pin";
var Block = "Block";
var Kick = "Kick";
var Enter = "Enter";
var Leave = "Leave";
var Participants = "Participants";
var Anonymous = ", and ({{ count }}) anonymous";
var en = {
	Joining: Joining,
	Mic: Mic,
	"No internet connection": "No internet connection",
	"Re-connecting": "Re-connecting",
	Ringing: Ringing,
	"Screen Share": "Screen Share",
	"Select a Camera": "Select a Camera",
	"Select a Mic": "Select a Mic",
	"Select Speakers": "Select Speakers",
	Speakers: Speakers,
	Video: Video,
	"You are muted. Unmute to speak.": "You are muted. Unmute to speak.",
	"Background filters performance is degraded. Consider disabling filters for better performance.": "Background filters performance is degraded. Consider disabling filters for better performance.",
	Live: Live,
	"Livestream starts soon": "Livestream starts soon",
	"Livestream starts at {{ startsAt }}": "Livestream starts at {{ startsAt, datetime }}",
	"{{ count }} participants joined early_one": "{{ count }} participant joined early",
	"{{ count }} participants joined early_other": "{{ count }} participants joined early",
	"You can now speak.": "You can now speak.",
	"Awaiting for an approval to speak.": "Awaiting for an approval to speak.",
	"You can no longer speak.": "You can no longer speak.",
	"You can now share your video.": "You can now share your video.",
	"Awaiting for an approval to share your video.": "Awaiting for an approval to share your video.",
	"You can no longer share your video.": "You can no longer share your video.",
	"Waiting for recording to stop...": "Waiting for recording to stop...",
	"Waiting for recording to start...": "Waiting for recording to start...",
	"Record call": "Record call",
	Reactions: Reactions,
	Statistics: Statistics,
	"You can now share your screen.": "You can now share your screen.",
	"Awaiting for an approval to share screen.": "Awaiting for an approval to share screen.",
	"You can no longer share your screen.": "You can no longer share your screen.",
	"Share screen": "Share screen",
	"Incoming Call...": "Incoming Call...",
	"Calling...": "Calling...",
	"Mute All": "Mute All",
	Invite: Invite,
	Join: Join,
	You: You,
	Me: Me,
	Unknown: Unknown,
	"Toggle device menu": "Toggle device menu",
	Default: Default,
	"Call Recordings": "Call Recordings",
	Refresh: Refresh,
	"Check your browser video permissions": "Check your browser video permissions",
	"Video publishing is disabled by the system": "Video publishing is disabled by the system",
	"You have no permission to share your video": "You have no permission to share your video",
	"You have no permission to share your audio": "You have no permission to share your audio",
	"You are presenting your screen": "You are presenting your screen",
	"Stop Screen Sharing": "Stop Screen Sharing",
	Allow: Allow,
	Revoke: Revoke,
	Dismiss: Dismiss,
	"Microphone on": "Microphone on",
	"Microphone off": "Microphone off",
	"Camera on": "Camera on",
	"Camera off": "Camera off",
	"No camera found": "No camera found",
	"Video is disabled": "Video is disabled",
	Pinned: Pinned,
	Unpin: Unpin,
	Pin: Pin,
	"Pin for everyone": "Pin for everyone",
	"Unpin for everyone": "Unpin for everyone",
	Block: Block,
	Kick: Kick,
	"Turn off video": "Turn off video",
	"Turn off screen share": "Turn off screen share",
	"Mute audio": "Mute audio",
	"Mute screen share audio": "Mute screen share audio",
	"Allow audio": "Allow audio",
	"Allow video": "Allow video",
	"Allow screen sharing": "Allow screen sharing",
	"Disable audio": "Disable audio",
	"Disable video": "Disable video",
	"Disable screen sharing": "Disable screen sharing",
	Enter: Enter,
	Leave: Leave,
	"Leave call": "Leave call",
	"End call for all": "End call for all",
	"{{ direction }} fullscreen": "{{ direction }} fullscreen",
	"{{ direction }} picture-in-picture": "{{ direction }} picture-in-picture",
	"Dominant Speaker": "Dominant Speaker",
	"Poor connection quality": "Poor connection quality. Please check your internet connection.",
	"Video paused due to insufficient bandwidth": "Video paused due to insufficient bandwidth",
	Participants: Participants,
	Anonymous: Anonymous,
	"No participants found": "No participants found",
	"Participants ({{ numberOfParticipants }})": "Participants ({{ numberOfParticipants }})",
	"{{ userName }} is sharing their screen": "{{ userName }} is sharing their screen",
	"{{ userName }} is requesting to speak": "{{ userName }} is requesting to speak",
	"{{ userName }} is requesting to share their camera": "{{ userName }} is requesting to share their camera",
	"{{ userName }} is requesting to present their screen": "{{ userName }} is requesting to present their screen",
	"{{ userName }} is requesting permission: {{ permission }}": "{{ userName }} is requesting permission: {{ permission }}"
};

const translations = { en };

const StreamVideo = (props) => {
    return (jsx(StreamVideoProvider, { translationsOverrides: translations, ...props }));
};
StreamVideo.displayName = 'StreamVideo';

function applyFilter(obj, filter) {
    if ('$and' in filter) {
        return filter.$and.every((f) => applyFilter(obj, f));
    }
    if ('$or' in filter) {
        return filter.$or.some((f) => applyFilter(obj, f));
    }
    if ('$not' in filter) {
        return !applyFilter(obj, filter.$not);
    }
    return checkConditions(obj, filter);
}
const isDateString = (value) => typeof value === 'string' &&
    /^((?:(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2}(?:\.\d+)?))(Z|[+-]\d{2}:\d{2})?)$/.test(value);
function checkConditions(obj, conditions) {
    let match = true;
    for (const key of Object.keys(conditions)) {
        const operator = conditions[key];
        const maybeOperator = operator && typeof operator === 'object';
        let value = obj[key];
        if (value instanceof Date) {
            value = value.getTime();
        }
        else if (isDateString(value)) {
            value = new Date(value).getTime();
        }
        if (maybeOperator && '$eq' in operator) {
            const eqOperator = operator;
            const eqOperatorValue = isDateString(eqOperator.$eq)
                ? new Date(eqOperator.$eq).getTime()
                : eqOperator.$eq;
            match && (match = eqOperatorValue === value);
        }
        else if (maybeOperator && '$neq' in operator) {
            const neqOperator = operator;
            match && (match = neqOperator.$neq !== value);
        }
        else if (maybeOperator && '$in' in operator) {
            const inOperator = operator;
            match && (match = inOperator.$in.includes(value));
        }
        else if (maybeOperator && '$contains' in operator) {
            if (Array.isArray(value)) {
                const containsOperator = operator;
                match && (match = value.includes(containsOperator.$contains));
            }
            else {
                match = false;
            }
        }
        else if (maybeOperator && '$gt' in operator) {
            const gtOperator = operator;
            const gtOperatorValue = isDateString(gtOperator.$gt)
                ? new Date(gtOperator.$gt).getTime()
                : gtOperator.$gt;
            match && (match = value > gtOperatorValue);
        }
        else if (maybeOperator && '$gte' in operator) {
            const gteOperator = operator;
            const gteOperatorValue = isDateString(gteOperator.$gte)
                ? new Date(gteOperator.$gte).getTime()
                : gteOperator.$gte;
            match && (match = value >= gteOperatorValue);
        }
        else if (maybeOperator && '$lt' in operator) {
            const ltOperator = operator;
            const ltOperatorValue = isDateString(ltOperator.$lt)
                ? new Date(ltOperator.$lt).getTime()
                : ltOperator.$lt;
            match && (match = value < ltOperatorValue);
        }
        else if (maybeOperator && '$lte' in operator) {
            const lteOperator = operator;
            const lteOperatorValue = isDateString(lteOperator.$lte)
                ? new Date(lteOperator.$lte).getTime()
                : lteOperator.$lte;
            match && (match = value <= lteOperatorValue);
            // } else if (maybeOperator && '$autocomplete' in operator) {
            // TODO: regexp solution maybe?
            // match &&= false;
        }
        else {
            const eqValue = operator;
            match && (match = eqValue === value);
        }
        if (!match) {
            return false;
        }
    }
    return true;
}

const useFilteredParticipants = ({ excludeLocalParticipant = false, filterParticipants, }) => {
    const { useParticipants, useRemoteParticipants } = useCallStateHooks();
    const allParticipants = useParticipants();
    const remoteParticipants = useRemoteParticipants();
    return useMemo(() => {
        const unfilteredParticipants = excludeLocalParticipant
            ? remoteParticipants
            : allParticipants;
        return filterParticipants
            ? applyParticipantsFilter(unfilteredParticipants, filterParticipants)
            : unfilteredParticipants;
    }, [
        allParticipants,
        remoteParticipants,
        excludeLocalParticipant,
        filterParticipants,
    ]);
};
const applyParticipantsFilter = (participants, filter) => {
    const filterCallback = typeof filter === 'function'
        ? filter
        : (participant) => applyFilter({
            userId: participant.userId,
            isSpeaking: participant.isSpeaking,
            isDominantSpeaker: participant.isDominantSpeaker,
            name: participant.name,
            roles: participant.roles,
            isPinned: isPinned(participant),
            hasVideo: hasVideo(participant),
            hasAudio: hasAudio(participant),
            hasScreenShare: hasScreenShare(participant),
        }, filter);
    return participants.filter(filterCallback);
};
const usePaginatedLayoutSortPreset = (call) => {
    useEffect(() => {
        if (!call)
            return;
        call.setSortParticipantsBy(paginatedLayoutSortPreset);
        return () => {
            resetSortPreset(call);
        };
    }, [call]);
};
const useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {
    useEffect(() => {
        if (!call)
            return;
        // always show the remote participant in the spotlight
        if (isOneOnOneCall) {
            call.setSortParticipantsBy(combineComparators(screenSharing, loggedIn));
        }
        else {
            call.setSortParticipantsBy(speakerLayoutSortPreset);
        }
        return () => {
            resetSortPreset(call);
        };
    }, [call, isOneOnOneCall]);
};
const useRawRemoteParticipants = () => {
    const { useRawParticipants } = useCallStateHooks();
    const rawParticipants = useRawParticipants();
    return useMemo(() => rawParticipants.filter((p) => !p.isLocalParticipant), [rawParticipants]);
};
const resetSortPreset = (call) => {
    // reset the sorting to the default for the call type
    const callConfig = CallTypes.get(call.type);
    call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || defaultSortPreset);
};
const loggedIn = (a, b) => {
    if (a.isLocalParticipant)
        return 1;
    if (b.isLocalParticipant)
        return -1;
    return 0;
};

const LivestreamLayout = (props) => {
    const { useParticipants, useHasOngoingScreenShare } = useCallStateHooks();
    const call = useCall();
    const participants = useParticipants();
    const [currentSpeaker] = participants;
    const remoteParticipants = useRawRemoteParticipants();
    const hasOngoingScreenShare = useHasOngoingScreenShare();
    const presenter = hasOngoingScreenShare
        ? participants.find(hasScreenShare)
        : undefined;
    usePaginatedLayoutSortPreset(call);
    const { floatingParticipantProps, muted, ParticipantViewUI } = props;
    const overlay = ParticipantViewUI ?? (jsx(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showMuteButton: props.showMuteButton, showSpeakerName: props.showSpeakerName, enableFullScreen: props.enableFullScreen }));
    const floatingParticipantOverlay = hasOngoingScreenShare &&
        (ParticipantViewUI ?? (jsx(ParticipantOverlay
        // these elements aren't needed for the video feed
        , { 
            // these elements aren't needed for the video feed
            showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false, showDuration: floatingParticipantProps?.showDuration ?? false, showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false, showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true, enableFullScreen: floatingParticipantProps?.enableFullScreen ?? true })));
    return (jsxs("div", { className: "str-video__livestream-layout__wrapper", children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && (jsx(ParticipantView, { className: "str-video__livestream-layout__screen-share", participant: presenter, ParticipantViewUI: overlay, trackType: "screenShareTrack", muteAudio // audio is rendered by ParticipantsAudio
                : true })), currentSpeaker && (jsx(ParticipantView, { className: clsx(hasOngoingScreenShare &&
                    clsx('str-video__livestream-layout__floating-participant', `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? 'top-right'}`)), participant: currentSpeaker, ParticipantViewUI: floatingParticipantOverlay || overlay, mirror: props.mirrorLocalParticipantVideo !== false ? undefined : false, muteAudio // audio is rendered by ParticipantsAudio
                : true }))] }));
};
LivestreamLayout.displayName = 'LivestreamLayout';
const BackstageLayout = (props) => {
    const { showEarlyParticipantCount = true, humanizeParticipantCount = true } = props;
    const { useParticipantCount, useCallStartsAt } = useCallStateHooks();
    const participantCount = useParticipantCount();
    const startsAt = useCallStartsAt();
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__livestream-layout__wrapper", children: jsxs("div", { className: "str-video__livestream-layout__backstage", children: [startsAt && (jsx("span", { className: "str-video__livestream-layout__starts-at", children: startsAt.getTime() < Date.now()
                        ? t('Livestream starts soon')
                        : t('Livestream starts at {{ startsAt }}', { startsAt }) })), showEarlyParticipantCount && (jsx("span", { className: "str-video__livestream-layout__early-viewers-count", children: t('{{ count }} participants joined early', {
                        count: humanizeParticipantCount
                            ? humanize(participantCount)
                            : participantCount,
                    }) }))] }) }));
};
BackstageLayout.displayName = 'BackstageLayout';
const ParticipantOverlay = (props) => {
    const { enableFullScreen = true, showParticipantCount = true, humanizeParticipantCount = true, showDuration = true, showLiveBadge = true, showMuteButton = true, showSpeakerName = false, } = props;
    const overlayBarVisible = enableFullScreen ||
        showParticipantCount ||
        showDuration ||
        showLiveBadge ||
        showMuteButton ||
        showSpeakerName;
    const { participant, participantViewElement } = useParticipantViewContext();
    const { useParticipantCount, useSpeakerState } = useCallStateHooks();
    const participantCount = useParticipantCount();
    const duration = useUpdateCallDuration();
    const toggleFullScreen = useToggleFullScreen();
    const { speaker, volume } = useSpeakerState();
    const isSpeakerMuted = volume === 0;
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__livestream-layout__overlay", children: overlayBarVisible && (jsxs("div", { className: "str-video__livestream-layout__overlay__bar", children: [showLiveBadge && (jsx("span", { className: "str-video__livestream-layout__live-badge", children: t('Live') })), showParticipantCount && (jsx("span", { className: "str-video__livestream-layout__viewers-count", children: humanizeParticipantCount
                        ? humanize(participantCount)
                        : participantCount })), showSpeakerName && (jsx("span", { className: "str-video__livestream-layout__speaker-name", title: participant.name || participant.userId || '', children: participant.name || participant.userId || '' })), showDuration && (jsx("span", { className: "str-video__livestream-layout__duration", children: formatDuration(duration) })), showMuteButton && (jsx("span", { className: clsx('str-video__livestream-layout__mute-button', isSpeakerMuted &&
                        'str-video__livestream-layout__mute-button--muted'), onClick: () => speaker.setVolume(isSpeakerMuted ? 1 : 0) })), enableFullScreen &&
                    participantViewElement &&
                    typeof participantViewElement.requestFullscreen !== 'undefined' && (jsx("span", { className: "str-video__livestream-layout__go-fullscreen", onClick: toggleFullScreen }))] })) }));
};
const useUpdateCallDuration = () => {
    const { useIsCallLive, useCallSession } = useCallStateHooks();
    const isCallLive = useIsCallLive();
    const session = useCallSession();
    const [duration, setDuration] = useState(() => {
        if (!session || !session.live_started_at)
            return 0;
        const liveStartTime = new Date(session.live_started_at);
        const now = new Date();
        return Math.floor((now.getTime() - liveStartTime.getTime()) / 1000);
    });
    useEffect(() => {
        if (!isCallLive)
            return;
        const interval = setInterval(() => {
            setDuration((d) => d + 1);
        }, 1000);
        return () => {
            clearInterval(interval);
        };
    }, [isCallLive]);
    return duration;
};
const useToggleFullScreen = () => {
    const { participantViewElement } = useParticipantViewContext();
    const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);
    useEffect(() => {
        const handler = () => setIsFullscreen(!!document.fullscreenElement);
        document.addEventListener('fullscreenchange', handler);
        return () => {
            document.removeEventListener('fullscreenchange', handler);
        };
    }, []);
    return useCallback(() => {
        if (isFullscreen) {
            document.exitFullscreen().catch((err) => {
                console.error('Failed to exit fullscreen', err);
            });
        }
        else {
            participantViewElement?.requestFullscreen().catch((err) => {
                console.error('Failed to enter fullscreen', err);
            });
        }
    }, [isFullscreen, participantViewElement]);
};
const formatDuration = (durationInMs) => {
    const days = Math.floor(durationInMs / 86400);
    const hours = Math.floor(durationInMs / 3600);
    const minutes = Math.floor((durationInMs % 3600) / 60);
    const seconds = durationInMs % 60;
    return `${days ? days + ' ' : ''}${hours ? hours + ':' : ''}${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
};

const GROUP_SIZE = 16;
const PaginatedGridLayoutGroup = ({ group, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI, }) => {
    return (jsx("div", { className: clsx('str-video__paginated-grid-layout__group', {
            'str-video__paginated-grid-layout--one': group.length === 1,
            'str-video__paginated-grid-layout--two-four': group.length >= 2 && group.length <= 4,
            'str-video__paginated-grid-layout--five-nine': group.length >= 5 && group.length <= 9,
        }), children: group.map((participant) => (jsx(ParticipantView, { participant: participant, muteAudio: true, mirror: mirror, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) }));
};
const PaginatedGridLayout = (props) => {
    const { groupSize = (props.groupSize || 0) > 0
        ? props.groupSize || GROUP_SIZE
        : GROUP_SIZE, excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, PictureInPicturePlaceholder, muted, } = props;
    const [page, setPage] = useState(0);
    const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement,] = useState(null);
    const call = useCall();
    const remoteParticipants = useRawRemoteParticipants();
    const participants = useFilteredParticipants({
        excludeLocalParticipant,
        filterParticipants,
    });
    usePaginatedLayoutSortPreset(call);
    useEffect(() => {
        if (!paginatedGridLayoutWrapperElement || !call)
            return;
        const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);
        return () => cleanup();
    }, [paginatedGridLayoutWrapperElement, call]);
    // only used to render video elements
    const participantGroups = useMemo(() => chunk(participants, groupSize), [participants, groupSize]);
    const pageCount = participantGroups.length;
    // update page when page count is reduced and selected page no longer exists
    useEffect(() => {
        if (page > pageCount - 1) {
            setPage(Math.max(0, pageCount - 1));
        }
    }, [page, pageCount]);
    const selectedGroup = participantGroups[page];
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    return (jsxs("div", { className: "str-video__paginated-grid-layout__wrapper", ref: setPaginatedGridLayoutWrapperElement, children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), jsxs("div", { className: "str-video__paginated-grid-layout", children: [pageArrowsVisible && pageCount > 1 && (jsx(IconButton, { icon: "caret-left", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) })), selectedGroup && (jsx(PaginatedGridLayoutGroup, { group: selectedGroup, mirror: mirror, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI, PictureInPicturePlaceholder: PictureInPicturePlaceholder })), pageArrowsVisible && pageCount > 1 && (jsx(IconButton, { disabled: page === pageCount - 1, icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) }))] })] }));
};
PaginatedGridLayout.displayName = 'PaginatedGridLayout';

const useCalculateHardLimit = (
/**
 * Element that stretches to 100% of the whole layout component
 */
wrapperElement, 
/**
 * Element that directly hosts individual `ParticipantView` (or wrapper) elements
 */
hostElement, limit) => {
    const [calculatedLimit, setCalculatedLimit] = useState({
        vertical: typeof limit === 'number' ? limit : null,
        horizontal: typeof limit === 'number' ? limit : null,
    });
    useEffect(() => {
        if (!hostElement ||
            !wrapperElement ||
            typeof limit === 'number' ||
            typeof limit === 'undefined')
            return;
        let childWidth = null;
        let childHeight = null;
        const resizeObserver = new ResizeObserver((entries, observer) => {
            // this part should ideally run as little times as possible
            // get child measurements and disconnect
            // does not consider dynamically sized children
            // this hook is for SpeakerLayout use only, where children in the bar are fixed size
            if (entries.length > 1) {
                const child = hostElement.firstChild;
                if (child) {
                    childHeight = child.clientHeight;
                    childWidth = child.clientWidth;
                    observer.unobserve(hostElement);
                }
            }
            // keep the state at { vertical: 1, horizontal: 1 }
            // until we get the proper child measurements
            if (childHeight === null || childWidth === null)
                return;
            const vertical = Math.floor(wrapperElement.clientHeight / childHeight);
            const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);
            setCalculatedLimit((pv) => {
                if (pv.vertical !== vertical || pv.horizontal !== horizontal)
                    return { vertical, horizontal };
                return pv;
            });
        });
        resizeObserver.observe(wrapperElement);
        resizeObserver.observe(hostElement);
        return () => {
            resizeObserver.disconnect();
        };
    }, [hostElement, limit, wrapperElement]);
    return calculatedLimit;
};

const DefaultParticipantViewUIBar = () => (jsx(DefaultParticipantViewUI, { menuPlacement: "top-end" }));
const SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUI, VideoPlaceholder, PictureInPicturePlaceholder, participantsBarPosition = 'bottom', participantsBarLimit, mirrorLocalParticipantVideo = true, excludeLocalParticipant = false, filterParticipants, pageArrowsVisible = true, muted, enableDragToScroll = false, }) => {
    const call = useCall();
    const { useParticipants } = useCallStateHooks();
    const allParticipants = useParticipants();
    const remoteParticipants = useRawRemoteParticipants();
    const [participantInSpotlight, ...otherParticipants] = useFilteredParticipants({ excludeLocalParticipant, filterParticipants });
    const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = useState(null);
    const [participantsBarElement, setParticipantsBarElement] = useState(null);
    const [buttonsWrapperElement, setButtonsWrapperElement] = useState(null);
    const isSpeakerScreenSharing = participantInSpotlight && hasScreenShare(participantInSpotlight);
    const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);
    const isVertical = participantsBarPosition === 'left' || participantsBarPosition === 'right';
    const isHorizontal = participantsBarPosition === 'top' || participantsBarPosition === 'bottom';
    useEffect(() => {
        if (!participantsBarWrapperElement || !call)
            return;
        const cleanup = call.setViewport(participantsBarWrapperElement);
        return () => cleanup();
    }, [participantsBarWrapperElement, call]);
    const isOneOnOneCall = allParticipants.length === 2;
    useSpeakerLayoutSortPreset(call, isOneOnOneCall);
    useDragToScroll(participantsBarWrapperElement, {
        enabled: enableDragToScroll,
    });
    let participantsWithAppliedLimit = otherParticipants;
    const hardLimitToApply = isVertical
        ? hardLimit.vertical
        : hardLimit.horizontal;
    if (typeof participantsBarLimit !== 'undefined' &&
        hardLimitToApply !== null) {
        participantsWithAppliedLimit = otherParticipants.slice(0, 
        // subtract 1 if speaker is sharing screen as
        // that one is rendered independently from otherParticipants array
        hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0));
    }
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    const renderParticipantsBar = participantsBarPosition &&
        (participantsWithAppliedLimit.length > 0 || isSpeakerScreenSharing);
    return (jsxs("div", { className: "str-video__speaker-layout__wrapper", children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), jsxs("div", { className: clsx('str-video__speaker-layout', participantsBarPosition &&
                    `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [jsx("div", { className: "str-video__speaker-layout__spotlight", children: participantInSpotlight && (jsx(ParticipantView, { participant: participantInSpotlight, muteAudio: true, mirror: mirror, trackType: isSpeakerScreenSharing ? 'screenShareTrack' : 'videoTrack', ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder })) }), renderParticipantsBar && (jsxs("div", { ref: setButtonsWrapperElement, className: "str-video__speaker-layout__participants-bar-buttons-wrapper", children: [jsx("div", { className: "str-video__speaker-layout__participants-bar-wrapper", ref: setParticipantsBarWrapperElement, children: jsxs("div", { ref: setParticipantsBarElement, className: "str-video__speaker-layout__participants-bar", children: [isSpeakerScreenSharing && (jsx("div", { className: "str-video__speaker-layout__participant-tile", children: jsx(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, mirror: mirror, muteAudio: true }) }, participantInSpotlight.sessionId)), participantsWithAppliedLimit.map((participant) => (jsx("div", { className: "str-video__speaker-layout__participant-tile", children: jsx(ParticipantView, { participant: participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, mirror: mirror, muteAudio: true }) }, participant.sessionId)))] }) }), pageArrowsVisible && isVertical && (jsx(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement })), pageArrowsVisible && isHorizontal && (jsx(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement }))] }))] })] }));
};
SpeakerLayout.displayName = 'SpeakerLayout';
const HorizontalScrollButtons = ({ scrollWrapper, }) => {
    const scrollPosition = useHorizontalScrollPosition(scrollWrapper);
    const scrollStartClickHandler = () => {
        scrollWrapper?.scrollBy({ left: -150, behavior: 'smooth' });
    };
    const scrollEndClickHandler = () => {
        scrollWrapper?.scrollBy({ left: 150, behavior: 'smooth' });
    };
    return (jsxs(Fragment, { children: [scrollPosition && scrollPosition !== 'start' && (jsx(IconButton, { onClick: scrollStartClickHandler, icon: "caret-left", className: "str-video__speaker-layout__participants-bar--button-left" })), scrollPosition && scrollPosition !== 'end' && (jsx(IconButton, { onClick: scrollEndClickHandler, icon: "caret-right", className: "str-video__speaker-layout__participants-bar--button-right" }))] }));
};
const VerticalScrollButtons = ({ scrollWrapper, }) => {
    const scrollPosition = useVerticalScrollPosition(scrollWrapper);
    const scrollTopClickHandler = () => {
        scrollWrapper?.scrollBy({ top: -150, behavior: 'smooth' });
    };
    const scrollBottomClickHandler = () => {
        scrollWrapper?.scrollBy({ top: 150, behavior: 'smooth' });
    };
    return (jsxs(Fragment, { children: [scrollPosition && scrollPosition !== 'top' && (jsx(IconButton, { onClick: scrollTopClickHandler, icon: "caret-up", className: "str-video__speaker-layout__participants-bar--button-top" })), scrollPosition && scrollPosition !== 'bottom' && (jsx(IconButton, { onClick: scrollBottomClickHandler, icon: "caret-down", className: "str-video__speaker-layout__participants-bar--button-bottom" }))] }));
};

const Pip = (props) => {
    const { t } = useI18n();
    const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, } = props;
    const [layoutWrapperElement, setLayoutWrapperElement] = useState(null);
    const call = useCall();
    const participants = useFilteredParticipants({
        excludeLocalParticipant,
        filterParticipants,
    });
    const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
    usePaginatedLayoutSortPreset(call);
    useEffect(() => {
        if (!layoutWrapperElement || !call)
            return;
        return call.setViewport(layoutWrapperElement);
    }, [layoutWrapperElement, call]);
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    return (jsxs("div", { className: "str-video__pip-layout", ref: setLayoutWrapperElement, children: [screenSharingParticipant &&
                (screenSharingParticipant.isLocalParticipant ? (jsxs("div", { className: "str-video__pip-screen-share-local", children: [jsx(Icon, { icon: "screen-share-off" }), jsx("span", { className: "str-video__pip-screen-share-local__title", children: t('You are presenting your screen') })] })) : (jsx(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }))), participants.map((participant) => (jsx(ParticipantView, { participant: participant, muteAudio: true, mirror: mirror, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId)))] }));
};
Pip.displayName = 'PipLayout.Pip';

const Host = () => {
    const remoteParticipants = useRawRemoteParticipants();
    return jsx(ParticipantsAudio, { participants: remoteParticipants });
};
Host.displayName = 'PipLayout.Host';

const getGridDensity = (count) => {
    if (count === 1)
        return 'single';
    if (count <= 5)
        return 'small';
    if (count <= 9)
        return 'medium';
    if (count <= 16)
        return 'large';
    return 'overflow';
};
/**
 * A grid-based PIP layout with pagination support.
 * Use this when you need a more structured grid view in PIP mode.
 */
const Grid = (props) => {
    const { t } = useI18n();
    const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, groupSize = 9, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, } = props;
    const [page, setPage] = useState(0);
    const [wrapperElement, setWrapperElement] = useState(null);
    const call = useCall();
    const participants = useFilteredParticipants({
        excludeLocalParticipant,
        filterParticipants,
    });
    const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
    usePaginatedLayoutSortPreset(call);
    useEffect(() => {
        if (!wrapperElement || !call)
            return;
        return call.setViewport(wrapperElement);
    }, [wrapperElement, call]);
    const participantGroups = useMemo(() => chunk(participants, groupSize), [participants, groupSize]);
    const pageCount = participantGroups.length;
    if (page > pageCount - 1) {
        setPage(Math.max(0, pageCount - 1));
    }
    const selectedGroup = participantGroups[page];
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    return (jsxs("div", { className: "str-video__pip-layout str-video__pip-layout--grid", ref: setWrapperElement, children: [screenSharingParticipant &&
                (screenSharingParticipant.isLocalParticipant ? (jsxs("div", { className: "str-video__pip-screen-share-local", children: [jsx(Icon, { icon: "screen-share-off" }), jsx("span", { className: "str-video__pip-screen-share-local__title", children: t('You are presenting your screen') })] })) : (jsx(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }))), jsxs("div", { className: "str-video__pip-layout__grid-container", children: [pageArrowsVisible && page > 0 && (jsx(IconButton, { icon: "caret-left", onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)), className: "str-video__pip-layout__pagination-button str-video__pip-layout__pagination-button--left" })), selectedGroup && (jsx("div", { className: clsx('str-video__pip-layout__grid', `str-video__pip-layout__grid--${getGridDensity(selectedGroup.length)}`), children: selectedGroup.map((participant) => (jsx(ParticipantView, { participant: participant, muteAudio: true, mirror: mirror, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) })), pageArrowsVisible && page < pageCount - 1 && (jsx(IconButton, { icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)), className: "str-video__pip-layout__pagination-button str-video__pip-layout__pagination-button--right" }))] })] }));
};
Grid.displayName = 'PipLayout.Grid';

const PipLayout = { Pip, Host, Grid };

const LivestreamPlayer = (props) => {
    const { callType, callId, children, ...restProps } = props;
    const client = useStreamVideoClient();
    const [call, setCall] = useState();
    const onError = useEffectEvent(props.onError ?? (() => { }));
    useEffect(() => {
        if (!client)
            return;
        const myCall = client.call(callType, callId);
        setCall(myCall);
        myCall.get().catch((e) => {
            console.error('Failed to fetch call', e);
            onError(e);
        });
        return () => {
            myCall.leave().catch((e) => {
                console.error('Failed to leave call', e);
            });
            setCall(undefined);
        };
    }, [callId, callType, client]);
    if (!call) {
        return null;
    }
    return (jsxs(StreamCall, { call: call, children: [jsx(LivestreamCall, { ...restProps }), children] }));
};
const LivestreamCall = (props) => {
    const call = useLivestreamCall(props);
    const { useIsCallLive } = useCallStateHooks();
    const isLive = useIsCallLive();
    if (!call)
        return null;
    if (isLive) {
        return jsx(LivestreamLayout, { ...props.layoutProps });
    }
    return jsx(BackstageLayout, { ...props.backstageProps });
};
const useLivestreamCall = (props) => {
    const call = useCall();
    const { useIsCallLive, useOwnCapabilities } = useCallStateHooks();
    const canJoinLive = useIsCallLive();
    const canJoinEarly = useCanJoinEarly();
    const canJoinBackstage = useOwnCapabilities()?.includes('join-backstage') ?? false;
    const canJoinAsap = canJoinLive || canJoinEarly || canJoinBackstage;
    const joinBehavior = props.joinBehavior ?? 'asap';
    const canJoin = (joinBehavior === 'asap' && canJoinAsap) ||
        (joinBehavior === 'live' && canJoinLive);
    const onError = useEffectEvent(props.onError ?? (() => { }));
    useEffect(() => {
        if (call && call.state.callingState === CallingState.IDLE && canJoin) {
            call.join().catch((e) => {
                console.error('Failed to join call', e);
                onError(e);
            });
        }
    }, [call, canJoin]);
    return call;
};
const useCanJoinEarly = () => {
    const { useCallStartsAt, useCallSettings } = useCallStateHooks();
    const startsAt = useCallStartsAt();
    const settings = useCallSettings();
    const joinAheadTimeSeconds = settings?.backstage.join_ahead_time_seconds;
    const [canJoinEarly, setCanJoinEarly] = useState(() => checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
    useEffect(() => {
        if (!canJoinEarly) {
            const handle = setInterval(() => {
                setCanJoinEarly(checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
            }, 1000);
            return () => clearInterval(handle);
        }
    }, [canJoinEarly, startsAt, joinAheadTimeSeconds]);
    return canJoinEarly;
};
const checkCanJoinEarly = (startsAt, joinAheadTimeSeconds) => {
    if (!startsAt) {
        return false;
    }
    return Date.now() >= +startsAt - (joinAheadTimeSeconds ?? 0) * 1000;
};

const [major, minor, patch] = ("1.32.1").split('.');
setSdkInfo({
    type: SfuModels.SdkType.REACT,
    major,
    minor,
    patch,
});

export { AcceptCallButton, Audio, AudioVolumeIndicator, Avatar, AvatarFallback, BackgroundFiltersProvider, BackstageLayout, BaseVideo, CallControls, CallParticipantListing, CallParticipantListingItem, CallParticipantsList, CallPreview, CallRecordingList, CallRecordingListHeader, CallRecordingListItem, CallStats, CallStatsButton, CancelCallButton, CancelCallConfirmButton, CompositeButton, DefaultParticipantViewUI, DefaultReactionsMenu, DefaultScreenShareOverlay, DefaultVideoPlaceholder, DeviceSelector, DeviceSelectorAudioInput, DeviceSelectorAudioOutput, DeviceSelectorVideo, DeviceSettings, DropDownSelect, DropDownSelectOption, EmptyCallRecordingListing, GenericMenu, GenericMenuButtonItem, Icon, IconButton, LivestreamLayout, LivestreamPlayer, LoadingCallRecordingListing, LoadingIndicator, MenuToggle, MenuVisualType, MicCaptureErrorNotification, NoiseCancellationProvider, Notification, PaginatedGridLayout, ParticipantActionsContextMenu, ParticipantDetails, ParticipantView, ParticipantViewContext, ParticipantsAudio, PermissionNotification, PermissionRequestList, PermissionRequests, PipLayout, Reaction, ReactionsButton, RecordCallButton, RecordCallConfirmationButton, RecordingInProgressNotification, RingingCall, RingingCallControls, ScreenShareButton, SearchInput, SearchResults, SpeakerLayout, SpeakerTest, SpeakingWhileMutedNotification, SpeechIndicator, StatCard, StreamCall, StreamTheme, StreamVideo, TextButton, ToggleAudioOutputButton, ToggleAudioPreviewButton, ToggleAudioPublishingButton, ToggleVideoPreviewButton, ToggleVideoPublishingButton, Tooltip, Video$1 as Video, VideoPreview, WithTooltip, applyFilter, defaultEmojiReactionMap, defaultReactions, translations, useBackgroundFilters, useDeviceList, useFilteredParticipants, useHorizontalScrollPosition, useMenuContext, useModeration, useNoiseCancellation, useParticipantViewContext, usePersistedDevicePreferences, useRequestPermission, useTrackElementVisibility, useVerticalScrollPosition };
//# sourceMappingURL=index.es.js.map
